#+title: GNU Emacs Config
#+author: nshan651

* Early Initialization
This is the first file that Emacs reads when starting up. It should contain code that does not depend on any package or the proportions of the Emacs frame. In general, this early initialization file is meant to set up a few basic things before Emacs produces the initial frame by delegating to the =init.el=.

** Basic frame settings
These are general frame settngs. Notice the frame-resize-pixelwise and frame-inhibit-implied-resize: by default Emacs will resize the frame if you adjust the font size, which I never want.

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq frame-resize-pixelwise t
        frame-inhibit-implied-resize t
        frame-title-format '("%b")
        ring-bell-function 'ignore
        use-dialog-box t ; only for mouse events, which I seldom use
        use-file-dialog nil
        use-short-answers t
        inhibit-splash-screen t
        inhibit-startup-screen t
        inhibit-startup-message t
        initial-scratch-message nil
        inhibit-x-resources t
        inhibit-startup-echo-area-message user-login-name ; read the docstring
        inhibit-startup-buffer-menu t)

  (set-fringe-mode 10) ; Give some breathing room

  (menu-bar-mode -1) ; Disable the menu bar

  ;; Disable graphical elements
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)

  ;; Default for fill column should be 80 (not 70 like emacs would have it!!!)
  (setq-default fill-column 80)
#+end_src

** Improve scrolling
#+begin_src emacs-lisp :tangle "early-init.el"
  ;; Improve mouse scrolling
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse

  ;; Start scrolling when cursor is with 25% of the top or bottom of the screen.
  (setq scroll-margin (floor (* 0.25 (window-height))))

  ;; Vim-like key scrolling
  (setq scroll-step 1
        scroll-conservatively 10000
        next-screen-context-lines 5
        ;; move by logical lines rather than visual lines (better for macros)
        line-move-visual nil)
#+end_src

** Line Numbering
#+begin_src emacs-lisp :tangle "early-init.el"
  (column-number-mode)
  (global-display-line-numbers-mode t)
  ;; Relative line numbers
  (menu-bar--display-line-numbers-mode-relative)

  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  shell-mode-hook
                  treemacs-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

  ;; Revert Dired and other buffers
  (setq global-auto-revert-non-file-buffers t)

  ;; Revert buffers when the underlying file has changed
  (global-auto-revert-mode 1)
#+end_src

** Garbage collection
Here we maximize the GC threshold to make Emacs boot a bit faster.

#+begin_src emacs-lisp :tangle "early-init.el"
;; Temporarily increase the garbage collection threshold.  These
;; changes help shave off about half a second of startup time.  The
;; `most-positive-fixnum' is DANGEROUS AS A PERMANENT VALUE.  See the
;; `emacs-startup-hook' a few lines below for what I actually use.
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.5)

;; Same idea as above for the `file-name-handler-alist' and the
;; `vc-handled-backends' with regard to startup speed optimisation.
;; Here I am storing the default value with the intent of restoring it
;; via the `emacs-startup-hook'.
(defvar ns-emacs--file-name-handler-alist file-name-handler-alist)
(defvar ns-emacs--vc-handled-backends vc-handled-backends)

(setq file-name-handler-alist nil
      vc-handled-backends nil)

(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold (* 1024 1024 20)
                  gc-cons-percentage 0.2
                  file-name-handler-alist ns-emacs--file-name-handler-alist
                  vc-handled-backends ns-emacs--vc-handled-backends)))
#+end_src

** Declare all themes as safe
#+begin_src emacs-lisp :tangle "early-init.el"
  (setq custom-safe-themes t)
#+end_src

** Initialize the package cache
I use the standard package.el.
#+begin_src emacs-lisp :tangle "early-init.el"
  ;; Initialise installed packages at this early stage, by using the available cache.
  (setq package-enable-at-startup t)
#+end_src

* Init Configuration
** Disable backups and lockfiles
#+begin_src emacs-lisp :tangle "init.el"
(setq make-backup-files nil)
(setq backup-inhibited nil) ; Not sure if needed, given `make-backup-files'
(setq create-lockfiles nil)
#+end_src

** Make native compilation silent
#+begin_src emacs-lisp :tangle "init.el"
;; Make native compilation silent and prune its cache.
(when (native-comp-available-p)
  (setq native-comp-async-report-warnings-errors 'silent) ; Emacs 28 with native compilation
  (setq native-compile-prune-cache t)) ; Emacs 29
#+end_src

** Send custom-file to the shadow realm
By default, Emacs writes persistent customisations to the end of the user’s init file. These are encapsulated in a “custom” block. Emacs writes those whenever the user does something with M-x customize or related.

I personally prefer writing the actual Elisp over using the interface of M-x customize. I also want my init file to only ever contain what I wrote and to never, ever evaluate code I have not called myself.

#+begin_src emacs-lisp :tangle "init.el"
;; Disable the damn thing by making it disposable.
(setq custom-file (make-temp-file "emacs-custom-"))
#+end_src

** Enable and disable certain commands
Some Emacs commands are disabled by default. This means that Emacs will produce a warning when we try to invoke them and will ask us for confirmation. Here I define which commands I want to have enabled and then put some on the disabled list.

#+begin_src emacs-lisp :tangle "init.el"
;; Enable these.
(mapc
 (lambda (command)
   (put command 'disabled nil))
 '(list-timers narrow-to-region narrow-to-page upcase-region downcase-region))

;; And disable these.
(mapc
 (lambda (command)
   (put command 'disabled t))
 '(project-eshell overwrite-mode iconify-frame diary))
#+end_src

** Pre-load package configs in =lisp= directory
#+begin_src emacs-lisp :tangle "init.el"
  (defun ns/load-lisp-config (file-list)
    "Loads all config files in lisp directory."
    (dolist (file file-list)
      (let ((full-path (locate-user-emacs-file (concat "lisp/" file))))
        (when (file-readable-p full-path)
          (load full-path)))))

  ;; Load paths in a specific order.
  (let ((ns/file-list
         '("evil-config.el"
           "theme-config.el"
           "development-config.el"
           "ui-config.el"
           "org-config.el"
           "org-roam-config.el"
           "programming-languages-config.el"
           "terminal-config.el"
           "applications-config.el"
           "window-config.el"
           "dired-config.el")))

    (ns/load-lisp-config ns/file-list))

  ;; Load gptel system prompts.
  ;; (load (locate-user-emacs-file "etc/prompts.el"))

  ;; Also load `feed.el'.
  (load (locate-user-emacs-file "etc/feed.el"))
#+end_src

** Package setup
Setup package archives for =package.el=.

#+begin_src emacs-lisp :tangle "init.el"
  ;; Packages
  (require 'package)

  (setq package-vc-register-as-project nil) ; Emacs 30

  (add-hook 'package-menu-mode-hook #'hl-line-mode)

  (setq package-archives
        '(("elpa" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))

  ;; Highest number gets priority (what is not mentioned has priority 0)
  (setq package-archive-priorities
        '(("elpa" . 2)
          ("melpa" . 1)))
#+end_src

** Load Some Basic Packages
These are just some nice packages to have around.

*** Async
Provides asynchronous bytecode compilation and various other actions.

#+begin_src emacs-lisp :tangle "init.el" :mkdirp yes
  (use-package async
    :defer t
    :init
    (dired-async-mode 1))
#+end_src

*** Savehist
Persist history over Emacs restarts. Vertico sorts by history position.
#+begin_src emacs-lisp :tangle "init.el" :mkdirp yes
  (use-package savehist
    :init
    (setq history-length 25)
    (savehist-mode t))
#+end_src
*** Repeat
#+begin_src emacs-lisp :tangle "init.el" :mkdirp yes
  (use-package repeat
    :defer 10
    :init
    (repeat-mode +1))
#+end_src

*** Clean Whitespaces
Automatically trim extraneous whitespaces.

#+begin_src emacs-lisp :tangle "init.el" :mkdirp yes
(use-package ws-butler
  :config
  (ws-butler-global-mode 1))
#+end_src

** Clipboard
#+begin_src emacs-lisp :tangle "init.el" :mkdirp yes
  (setq select-enable-clipboard t)
  (setq x-select-enable-clipboard t)
#+end_src

** Auth Source
Auth source is a built in way to manage secrets in Emacs. For now I'm just using this along with =password-sore= to manage API keys.
#+begin_src emacs-lisp :tangle "init.el" :mkdirp yes
  (use-package auth-source-pass
    :custom
    (auth-source-pass-filename
     (expand-file-name
      "password-store/apikeys"
      (or (getenv "XDG_DATA_HOME")
          (expand-file-name "~/.local/share"))))
    :init
    (auth-source-pass-enable))
#+end_src
* Keybindings
All my keybindings are controlled by evil mode.

** Evil Keybindings
Welcome to the dark side!  Load my custom keybindings.

#+begin_src emacs-lisp :tangle "lisp/evil-config.el" :mkdirp yes
  (use-package evil
    :custom
    (evil-want-integration t)
    (evil-want-keybinding nil)
    (evil-want-C-u-scroll t)
    (evil-want-C-i-jump nil)
    (evil-respect-visual-line-mode t)
    :config
    (evil-mode 1)
    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))
#+end_src

** Evil Collection
Evil collection adds some additional compatibility to modes that otherwise don't play well with evil-mode.
#+begin_src emacs-lisp :tangle "lisp/evil-config.el" :mkdirp yes
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

** General
General is the best method that I've found for organizing keybindings.

#+begin_src emacs-lisp :tangle "lisp/evil-config.el" :mkdirp yes
  (use-package general
    :after evil
    :config
    ;; General-purpose leader prefix.
    (general-create-definer ns/leader-spc
      :states '(normal visual)
      :keymaps 'override
      :prefix "SPC")
    ;; Cosmetics.
    (general-create-definer ns/leader-t
      :states 'normal
      :keymaps 'override
      :prefix "t")
    ;; Read-only docs.
    (general-create-definer ns/leader-r
      :states 'motion
      :prefix "r")
    ;; Magit operations.
    (general-create-definer ns/leader-m
      :states 'normal
      :prefix "m")
    ;; Window management.
    (general-create-definer ns/leader-ca
      :states 'normal
      :keymaps 'override
      :prefix "C-a")
    ;; Executive.
    (general-create-definer ns/leader-comma
      :states 'normal
      :prefix ","))
    ;; Misc.
    (general-create-definer ns/leader-ct
      :keymaps '(insert normal)
      :keymaps 'override
      :prefix "C-t")
#+end_src

** Basic Keybindings
These are basic keybindings that aren't tied to any particular package (except evil). I chose to group most of my keybindings by package. Personally, I find this approach makes it easier to find what I need.

#+begin_src emacs-lisp :tangle "lisp/evil-config.el" :mkdirp yes
  ;; Bind C-x C-b to ibuffer.
  (keymap-global-set "C-x C-b" 'ibuffer)
  ;; Make ESC quit prompts.
  (keymap-global-set "<escape>" 'keyboard-escape-quit)
  ;; Sensible copy-paste behavior.
  (keymap-global-set "C-S-c" 'copy-region-as-kill)
  (keymap-global-set "C-S-v" 'yank)

  ;; Use visual line motions even outside of visual-line-mode buffers
  (general-def 'motion
    "j" 'evil-next-visual-line
    "k" 'evil-previous-visual-line)

  (ns/leader-spc
    "f"  'find-file
    "k"  'kill-buffer
    "eb" 'eval-buffer)

  ;; Compiling and recompiling.
  (general-def 'normal
    :prefix "g"
    "c" 'compile
    "r" 'recompile)

  ;; Manage windows
  (ns/leader-ca 'override
    "<backspace>" 'delete-window
    "\\"          'split-window-right
    "-"           'split-window-below
    ;; Windmove keys for additional window navigation
    "h"          'windmove-left
    "l"           'windmove-right
    "k"          'windmove-up
    "j"           'windmove-down)

  ;; Window resizing
  ;; "C-h"        (lambda () (interactive) (shrink-window-horizontally 21))
  ;; "C-l"         (lambda () (interactive) (enlarge-window-horizontally 21))
  ;; "C-j"         (lambda () (interactive) (enlarge-window 11))
  ;; "C-k"        (lambda () (interactive) (shrink-window 11))

  ;; https://www.emacswiki.org/emacs/WindowResize
  (defun ns/define-x-pos ()
    "Find the window's position on the x-axis."
    (let* ((win-edges (window-edges))
           (x-min (nth 0 win-edges))
           (x-max (nth 2 win-edges))
           (max-width (+ 2 (frame-width))))
      (cond
       ((equal max-width x-max)
        "right")
       ((and (> x-min 0) (< x-max max-width))
        "mid")
       (t "left"))))

  (defun ns/win-resize-left ()
    (interactive)
    (let ((x-pos (ns/define-x-pos)))
      (cond
       ((equal "right" x-pos)
        (enlarge-window-horizontally +15))
       (t (enlarge-window-horizontally -15))
       ))
    )

  (defun ns/win-resize-right ()
    (interactive)
    (let ((x-pos (ns/define-x-pos)))
      (cond
       ((equal "right" x-pos)
        (enlarge-window-horizontally -15))
       (t (enlarge-window-horizontally +15))
       ))
    )

  (ns/leader-ca 'override
    "C-h"       (lambda () (interactive)
                  (ns/win-resize-left))
    "C-l"        (lambda () (interactive)
                   (ns/win-resize-right))
    "C-j"         (lambda () (interactive) (enlarge-window 11))
    "C-k"        (lambda () (interactive) (shrink-window 11)))

#+end_src
*** Commenting
Emacs' built in commenting functionality =comment-dwim= (usually bound to =M-;=) doesn't always comment things in the way you might expect so we use [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] to provide a more familiar behavior.  I've bound it to =M-/= since other editors sometimes use this binding but you could also replace Emacs' =M-;= binding with this command.

#+begin_src emacs-lisp :tangle "lisp/evil-config.el" :mkdirp yes
  (use-package evil-nerd-commenter
    :general ("M-/" 'evilnc-comment-or-uncomment-lines))
#+end_src
** Mouse Settings

* Theme Configuration
** Color Theme
#+begin_src emacs-lisp :tangle "lisp/theme-config.el" :mkdirp yes
  ;; Pull in some nice themes.
  (use-package modus-themes) ; Included since Emacs 27+.
  (use-package ef-themes)
  (use-package doom-themes)
#+end_src

** Custom theme
My custom color theme is a minor modification of =modus-vivendi=.
#+begin_src emacs-lisp :tangle "lisp/theme-config.el" :mkdirp yes
  (load-theme 'modus-vivendi)
  (set-face-attribute 'default nil :background "#1f1f1f")

  ;; Enhance org-mode elements.
  (with-eval-after-load 'org
    (set-face-attribute 'org-block nil :background "#2b2b2b")
    (set-face-attribute 'org-verbatim nil :foreground "#fffaaa" :weight 'bold)
    (set-face-attribute 'org-code nil :foreground "#ff599c"))

  ;; Make gptel-rewrite more readable.
  (with-eval-after-load 'gptel-rewrite
    (set-face-attribute 'gptel-rewrite-highlight-face nil
                        :inherit 'default
                        :background "#413847"
                        :extend t))
#+end_src

** Transparency
#+begin_src emacs-lisp :tangle "lisp/theme-config.el" :mkdirp yes
  (defun ns/toggle-transparency ()
    "Toggle transparency of Emacs frame."
    (interactive)
    (if (equal (car (frame-parameter (selected-frame) 'alpha)) 100)
        (set-frame-parameter (selected-frame) 'alpha '(90 . 90))
      (set-frame-parameter (selected-frame) 'alpha '(100 . 100))))

  ;; Binding to toggle between default and alt theme, inspired by 'modus-themes-toggle`
  (define-key global-map (kbd "<f4>") (lambda () (interactive)
                                        (ns/toggle-transparency)))
#+end_src

** Font Configuration
Set font details here.

#+begin_src emacs-lisp :tangle "lisp/theme-config.el" :mkdirp yes
  ;; Set base font sizes
  (defvar efs/default-font-size 110)
  (defvar efs/default-variable-font-size 110)

  (set-face-attribute 'default nil :font "Fira Code Retina" :height efs/default-font-size)

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height efs/default-font-size)

  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil :font "Cantarell" :height
                      efs/default-variable-font-size :weight 'regular)

  ;; Nerd icon fonts
  (use-package nerd-icons
    :custom
    ;; "Symbols Nerd Font Mono" is the recommended default.
    (nerd-icons-font-family "Symbols Nerd Font Mono"))
#+end_src
** Modeline
#+begin_src emacs-lisp :tangle "lisp/theme-config.el" :mkdirp yes
  (use-package doom-modeline
    :init (doom-modeline-mode 1))

  ;; Add some additional UI elements
  (display-time-mode 1)
#+end_src

** Tab Widths
#+begin_src emacs-lisp :tangle "lisp/theme-config.el" :mkdirp yes
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
  (setq-default c-basic-offset 4)
#+end_src

* UI Enhancements
Some UI enhancements that supercharge Emacs.

** Consult
#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package consult
    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    (setq consult-narrow-key "<"))
#+end_src

*** Consult Keybindings
#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  ;; Choose a theme.
  (ns/leader-t "t" '(consult-theme :wk "Choose a theme"))

  ;; Registers.
  (general-def 'override
    ("M-#" . consult-register-load)
    ("M-'" . consult-register-store)
    ("C-M-#" . consult-register)
    ("M-y" . consult-yank-pop))

  ;; Searching `search-mode-map'.
  (general-def 'override
    :keymaps 'isearch-mode-map
    "C-s" 'consult-line
    "M-e"  'consult-isearch-history
    "M-s e" 'consult-isearch-history)

  ;; Minibuffer history.
  (general-def 'override
    :keymaps 'minibuffer-local-map
    "M-s" 'consult-history)

  ;; Buffer management
  (ns/leader-spc
    ;; repeat-complex-command
    "M-:" 'consult-complex-command
    "b"   '(:ignore t :wk "consult buffer selection")
    ;; switch-to-buffer
    "bb"  '(consult-buffer :wk "consult buffer")
    ;; switch-to-buffer-other-window
    "b/"  '(consult-buffer-other-window :wk "open buffer in another window")
    ;; switch-to-buffer-other-frame
    "b\\" '(consult-buffer-other-frame :wk "open buffer in another frame")
    ;; bookmark-jump
    "br"  '(consult-bookmark :wk "bookmark jump")
    ;; project-switch-to-buffer
    "bp"  '(consult-project-buffer :wk "switch between project buffers"))

  ;; C-c bindings in `mode-specific-map'
  (general-def 'normal
    :keymaps 'mode-specific-map
    :prefix "C-c"
    "M-x" 'consult-mode-command
    "h"   'consult-history
    "k"   'consult-kmacro
    "m"   'consult-man
    "i"   'consult-info)

  ;; M-g bindings in `goto-map'
  (general-def 'normal
    :keymaps 'goto-map
    :prefix "M-g"
    "f"   'consult-flymake
    "g"   'consult-goto-line       ;; orig. goto-line
    "M-g" 'consult-goto-line       ;; orig. goto-line
    "o"   'consult-outline         ;; Alternative: consult-org-heading
    "m"   'consult-mark
    "k"   'consult-global-mark
    "i"   'consult-imenu
    "I"   'consult-imenu-multi)

  ;; M-s bindings in `search-map'
  (general-def '(normal insert visual emacs)
    :keymaps 'search-map
    :prefix "M-s"
    "d"   'consult-find            ;; Alt: consult-fd
    "D"   'consult-locate
    "g"   'consult-grep
    "G"   'consult-git-grep
    "r"   'consult-ripgrep
    "k"   'consult-keep-lines
    "u"   'consult-focus-lines)

  ;; Other custom bindings
  (general-def 'override "M-y" 'consult-yank-pop) ;; orig. yank-pop
#+end_src

** Undo System
Linear undo while maintaining all history.
#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package undo-fu
    :general
    ('normal
     "u" #'undo-fu-only-undo
     "U" #'undo-fu-only-redo
     "C-r" #'undo-fu-only-redo))

  ;; ignores encrypted files by default
  (use-package undo-fu-session
    :init (undo-fu-session-global-mode))
#+end_src

** Which Key
[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix.  For example, if you press =C-c= (hold control and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run.  This is very useful for learning the possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package which-key
    :defer 0
    :diminish which-key-mode
    :config
    (which-key-mode)
    (setq which-key-idle-delay 1))
#+end_src

** Vertico
[[https://github.com/minad/vertico][Vertico]] provides a performant and minimalistic vertical completion UI based on the default completion system.

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
    (defun ns/minibuffer-backward-kill (arg)
    "When minibuffer is completing a file name delete up to parent
  folder, otherwise delete a character backward"
    (interactive "p")
    (if minibuffer-completing-file-name
        ;; Borrowed from https://github.com/raxod502/selectrum/issues/498#issuecomment-803283608
        (if (string-match-p "/." (minibuffer-contents))
            (zap-up-to-char (- arg) ?/)
          (delete-minibuffer-contents))
        (delete-backward-char arg)))

    ;; Enable vertico
    (use-package vertico
      :init
      (vertico-mode)
      :bind (:map minibuffer-local-map
                  ("<backspace>" . ns/minibuffer-backward-kill)))

    ;; A few more useful configurations...
    (use-package emacs
      :init
      ;; Add prompt indicator to `completing-read-multiple'.
      ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
      (defun crm-indicator (args)
        (cons (format "[CRM%s] %s"
                      (replace-regexp-in-string
                       "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                       crm-separator)
                      (car args))
              (cdr args)))
      (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

      ;; Do not allow the cursor in the minibuffer prompt
      (setq minibuffer-prompt-properties
            '(read-only t cursor-intangible t face minibuffer-prompt))
      (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

      ;; Enable recursive minibuffers
      (setq enable-recursive-minibuffers t))
#+end_src

** Orderless
#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package orderless
    :custom
    (completion-styles '(orderless))
    (completion-category-overrides '((file (styles . (partial-completion))))))
#+end_src

** Embark
#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package embark
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
    ;; strategy, if you want to see the documentation from multiple providers.
    (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
    ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

  (general-def 'override
    "C-."   'embark-act
    "C-;"   'embark-dwim
    "C-h B" 'embark-bindings)
#+end_src

** Marginalia
The [[https://github.com/minad/marginalia][Marginalia]] package adds marginalia annotations to the minibuffer completions.

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  ;; Enable rich annotations using the Marginalia package
  (use-package marginalia
    :after vertico
    :demand t
    :config
    (marginalia-mode))
#+end_src

** Corfu
[[https://github.com/minad/corfu][Corfu]] enhances in-buffer completion with a small completion popup.

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package corfu
    :custom
    (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    (corfu-separator ?\s)          ;; Orderless field separator
    :init
    (global-corfu-mode))

  (use-package emacs
    :init
    (setq tab-always-indent 'complete))
#+end_src

** Helpful
[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers.  For example, if you use =describe-function=, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration.

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package helpful
    :commands (helpful-callable helpful-variable helpful-command helpful-key)
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-key] . helpful-key))
#+end_src


* Org
My capture templates, agenda views, and other Org customizations can be found in [[ns-orgmode.org]].

** Font Faces

The =efs/org-font-setup= function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we're editing a document in =org-mode=.  We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (defun efs/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil    :foreground 'unspecified :inherit 'fixed-pitch)
    (set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
    (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)
    (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
    (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch))
#+end_src

** Basic Org Config
This section contains the basic configuration for =org-mode= plus the configuration for Org agendas and capture templates.

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (defun ns/org-mode-setup ()
    (org-indent-mode)
    (flyspell-mode)
    ;; (variable-pitch-mode)
    (visual-line-mode 1))

  (use-package org
    :ensure nil ; Built-in to emacs, do not install.
    :commands (org-capture org-agenda)
    :hook
    (org-mode . ns/org-mode-setup)
    :custom
    (org-M-RET-may-split-line '((default . nil)))
    (org-insert-heading-respect-content t)
    (org-log-done 'time)
    (org-log-into-drawer t)
    :config
    (setq org-ellipsis " ▾"
          org-hide-emphasis-markers t
          org-src-fontify-natively t
          org-fontify-quote-and-verse-blocks t
          org-hide-block-startup nil
          org-startup-folded 'content
          org-cycle-separator-lines 2
          org-capture-bookmark nil)

    (setq org-modules
          '(org-habit))

    ;; Resize latex figures
    (setq org-format-latex-options
          (plist-put org-format-latex-options :scale 1.5))

    (setq org-habit-graph-column 60)

    ;; Save Org buffers after refiling!
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (efs/org-font-setup))
     #+end_src

** Org Agenda

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  ;; Open the agenda file as the only window
  (setq org-agenda-window-setup 'only-window)
  (setq org-agenda-files
        '("~/ark/org/agenda/todo.org"       ; General unsorted todo items.
          "~/ark/org/agenda/inbox.org"      ; TBD!
          "~/ark/org/agenda/contacts.org"   ; Contacts list.
          "~/ark/org/agenda/projects.org"   ; Project mgmt.
          "~/ark/org/agenda/cron.org"       ; Recurring events/habits.
          ))

  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
          (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "PROJECT(x)" "|" "COMPLETED(c)" "CANC(k@)")
          (sequence "CONTACT(C)")))

  (setq org-refile-targets
        '(("archive.org" :maxlevel . 1)
          ("todo.org" :maxlevel . 1)))

  (setq org-tag-alist
        '((:startgroup)
           ;; Put mutually exclusive tags here
          (:endgroup)
          ("@errand" . ?E)
          ("@home" . ?H)
          ("@work" . ?W)
          ("@investing" . ?I)
          ("agenda" . ?a)
          ("followup" . ?f)
          ("planning" . ?p)
          ("publish" . ?P)
          ("batch" . ?b)
          ("note" . ?n)
          ("idea" . ?i)))

  ;; Configure custom agenda views
  ;; More on agenda view commands at `https://emacsdocs.org/docs/org/Agenda-Commands'
  (setq org-agenda-custom-commands
        `(("A" "Daily agenda and top priority tasks"
           ((tags-todo "*"
                       ((org-agenda-skip-function '(org-agenda-skip-if nil '(timestamp)))
                        (org-agenda-skip-function
                         `(org-agenda-skip-entry-if
                           'notregexp ,(format "\\[#%s\\]" (char-to-string org-priority-highest))))
                        (org-agenda-block-separator nil)
                        (org-agenda-overriding-header "Important Tasks Without a Date\n")))
            (agenda "" ((org-agenda-span 1)
                        (org-deadline-warning-days 0)
                        (org-agenda-block-separator nil)
                        (org-scheduled-past-days 0)
                        (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                        (org-agenda-format-date "%A %-e %B %Y")
                        (org-agenda-overriding-header "\nToday's Agenda\n")))
            (agenda "" ((org-agenda-start-on-weekday nil)
                        (org-agenda-start-day "+1d")
                        (org-agenda-span 3)
                        (org-deadline-warning-days 0)
                        (org-agenda-block-separator nil)
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                        (org-agenda-overriding-header "\nNext Three Days\n")))
            (agenda "" ((org-agenda-time-grid nil)
                        (org-agenda-start-on-weekday nil)
                        ;; We don't want to replicate the previous section's
                        ;; three days, so we start counting from the day after.
                        (org-agenda-start-day "+4d")
                        (org-agenda-span 14)
                        (org-agenda-show-all-dates nil)
                        (org-deadline-warning-days 0)
                        (org-agenda-block-separator nil)
                        (org-agenda-entry-types '(:deadline))
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                        (org-agenda-overriding-header "\nUpcoming Deadlines (+14d)\n")))
            (todo "PROJECT"
                  ((org-agenda-skip-function '(org-agenda-skip-if nil '(timestamp)))
                   (org-agenda-block-separator nil)
                   (org-agenda-overriding-header "\nProjects\n")))
            ))

          ("d" "Dashboard"
           ((agenda ""
                    (
                     (org-agenda-span 7)
                     (org-deadline-warning-days 0)
                     (org-scheduled-past-days 0)
                     (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                     (org-agenda-format-date "%A %-e %B %Y")
                     (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))
            (tags-todo "+PRIORITY=\"A\""
                       ((org-agenda-overriding-header "High Priority")))
            (tags-todo "+followup" ((org-agenda-overriding-header "Needs Follow Up")))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Actions")
                   (org-agenda-max-todos nil)))
            (todo "TODO"
                  ((org-agenda-overriding-header "Unprocessed Inbox Tasks")
                   (org-agenda-files '("~/ark/org/agenda/inbox.org"))
                   (org-agenda-text-search-extra-files nil)))
            (agenda "" ((org-agenda-span 14)
                        (org-agenda-start-day "+7d")
                        (org-deadline-warning-days 0)
                        (org-agenda-block-separator nil)
                        (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                        (org-agenda-format-date "%A %-e %B %Y")
                        (org-agenda-entry-types '(:deadline :scheduled))
                        (org-agenda-overriding-header "Upcoming Deadlines (+14d)")))
            ))
          ))

  (setq org-capture-templates
        `(("t" "Tasks")
          ("tt" "Task" entry (file "~/ark/org/agenda/todo.org")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("ts" "Clocked Entry Subtask" entry (clock)
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("tr" "Recurring Task" entry (file "~/ark/org/agenda/recurrent.org")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

          ;; Projects
          ("p" "Projects")
          ("pt" "Task" entry (file "~/ark/org/agenda/projects.org")
           "* PROJECT %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("ps" "Clocked Entry Subtask" entry (clock)
           "* PROJECT %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("pr" "Pull Request" entry (file "~/ark/org/agenda/projects.org")
           "* TODO %?\n  :PROPERTIES:\n:DATE: %U\n:LINK: %^L \n:END:" :empty-lines 1)

          ;; Contacts
          ("c" "Contacts" entry (file "~/ark/org/agenda/contacts.org")
           "* CONTACT %^{Name}\n:PROPERTIES:\n:DATE: %^{Specify birthday}t\n:PHONE: %^{Phone number}\n:END:\n%?" :empty-lines 1)

          ;; Journal Entries
          ("j" "Journal Entries")
          ("je" "General Entry" entry
           (file+olp+datetree "~/ark/org/journal/journal.org")
           "\n* %<%I:%M %p> - %^{Title} \n\n%?\n\n"
           :tree-type week
           :clock-in :clock-resume
           :empty-lines 1)
          ("jt" "Task Entry" entry
           (file+olp+datetree "~/ark/org/journal/journal.org")
           "\n* %<%I:%M %p> - Task Notes: %a\n\n%?\n\n"
           :tree-type week
           :clock-in :clock-resume
           :empty-lines 1)
          ("jj" "Journal" entry
           (file+olp+datetree "~/ark/org/journal/journal.org")
           "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
           :tree-type week
           :clock-in :clock-resume
           :empty-lines 1)))

  (define-key global-map (kbd "C-c j")
              (lambda () (interactive) (org-capture nil "jj")))

#+end_src

** Nicer Heading Bullets
org-bullets replaces the heading stars in org-mode buffers with nicer looking characters that you can control.

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
 #+end_src

** Center Org Buffers
We use visual-fill-column to center org-mode buffers for a more pleasing writing experience as it centers the contents of the buffer horizontally to seem more like you are editing a document.

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (defun efs/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . efs/org-mode-visual-fill))
 #+end_src

** Auto-show Markup Symbols
#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (use-package org-appear
     :hook (org-mode . org-appear-mode))
#+end_src

* Org Modules and Packages
** Evil Org
#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (use-package evil-org
    :after org
    :hook (org-mode . (lambda () evil-org-mode))
    :config
    (require 'evil-org-agenda)
    (evil-org-set-key-theme '(navigation todo insert textobjects additional))
    (evil-org-agenda-set-keys))

  (ns/leader-spc 'override
    "o"   '(:ignore t :wk "org mode")

    "oi"  '(:ignore t :wk "insert")
    "oil" '(org-insert-link :wk "insert link")

    "oo"  '(org-agenda :wk "open agenda")

    "on"  '(org-toggle-narrow-to-subtree :wk "toggle narrow")
    "os"  '(consult-org-roam-search :wk "search notes")
    ;; "oa"  '(org-agenda :wk "status")
    "ot"  '(org-todo-list :wk "todos")
    "oc"  '(org-capture t :wk "capture")
    "ox"  '(org-export-dispatch t :wk "export"))

  (defun ns/open-custom-agenda ()
    "Open the custom agenda view."
    (interactive)
    (org-agenda nil "d"))

  (general-def 'override
    :prefix "C-c"
    "a" '(org-agenda :wk "org agenda")
    "c" '(org-capture :wk "org capture")
    "d" '(ns/open-custom-agenda :wk "main agenda dashboard")
    )
#+end_src

** Babel
To execute or export code in =org-mode= code blocks, you'll need to set up =org-babel-load-languages= for each language you'd like to use.  [[https://orgmode.org/worg/org-contrib/babel/languages.html][This page]] documents all of the languages that you can use with =org-babel=.

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (with-eval-after-load 'org
    (org-babel-do-load-languages
        'org-babel-load-languages
        '(
          (emacs-lisp . t)
          (python . t)
          (shell . t)
          (C . t)
         ))
    (push '("conf-unix" . conf-unix) org-src-lang-modes))
  ;; Disable execution confirmations
  (setq org-confirm-babel-evaluate nil)
#+end_src

** Structure Templates
Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files in combination with =org-tempo= by typing followed by the template name like =el= or =py= and then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =el= and press =TAB= to expand into such a block.

You can add more =src= block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].

 #+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
   (use-package org-tempo
     :ensure nil
     :after org
     :config
     (let ((templates '(("sh"  . "src sh")
                        ("el"  . "src emacs-lisp")
                        ("ini" . "src emacs-lisp :tangle \"init.el\" :mkdirp yes")
                        ("vim" . "src vim")
                        ("py"  . "src python")
                        ("rs"  . "src rust")
                        ("cs"  . "src csharp")
                        ("y"  . "src yaml")
                        ;; Leetcode snippet
                        ("leet" .
                         "src C++ :includes <iostream> :flags -I./src/util -std=c++20 :tangle src/ .cpp")

                        ("cpp" . "src C++ :includes <iostream>"))))
       (dolist (template templates)
         (push template org-structure-template-alist))))
#+end_src

** Org Journal
 #+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
   (use-package org-journal
     :custom
     (org-journal-dir "~/ark/org/journal/"))

   (ns/leader-spc 'override
     "oj"  '(:ignore t :wk "org journal")
     "ojn" '(org-journal-new-entry :wk "new journal entry")
     "ojs" '(org-journal-search-forever :wk "search journal"))

 #+end_src

** Org Drill
Org drill is a spaced repetition algorithm that uses org files as sources of "facts" to be memorized. The =Anki= application took heavy inspiration from this package.
 #+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
   (use-package org-drill)
 #+end_src

* Org Roam
** Org Roam Config
[[[[https://github.com/org-roam/org-roam]]][Org Roam]] is a plain-text, graph-based personal knowledge management system.

#+begin_src emacs-lisp :tangle "lisp/org-roam-config.el" :mkdirp yes
  (use-package org-roam
    :custom
    (org-roam-directory (file-truename "~/ark/org"))
    (org-roam-dailies-directory "~/ark/org/journal")
    (org-roam-completion-everywhere t)
    :config
    (org-roam-db-autosync-mode)

    ;; If you're using a vertical completion framework, you might want a more informative completion interface
    ;; (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
    ;; If using org-roam-protocol
    ;; (require 'org-roam-protocol)
    )

  ;; Keybindings
  (ns/leader-spc
    "n"  '(:ignore t :wk "org node selection")
    "nl" '(org-roam-buffer-toggle :wk "org roam buffer toggle")
    "nf" '(org-roam-node-find :wk "org roam buffer find")
    ;; "ng" '(org-roam-graph :wk "org roam graph")
    "ni" '(org-roam-node-insert :wk "org roam insert")
    "nc" '(org-roam-capture :wk "org roam capture")
    "nj" '(org-roam-dailies-capture-today :wk "org roam dailies capture today"))

#+end_src

** Org Roam Capture Templates
Org roam allows you to create various capture templates.

#+begin_src emacs-lisp :tangle "lisp/org-roam-config.el" :mkdirp yes
  (setq org-roam-capture-templates
    '(("m" "main" plain
        "%?"
        :if-new
        (file+head "main/%<%Y%m%d%H%M%S>-${slug}.org"
                   "#+title: ${title}\n#+options: tex:t toc:nil\n#+startup: inlineimages latexpreview\n")
        :immediate-finish t
        :unnarrowed t)
        ("r" "reference" plain "%?"
        :if-new
        (file+head "reference/${title}.org"
                   "#+title: ${title}\n#+options: tex:t toc:nil\n#+startup: inlineimages latexpreview\n")
        :immediate-finish t
        :unnarrowed t)
        ("a" "article" plain "%?"
        :if-new
        (file+head "articles/${title}.org"
                   "#+title: ${title}\n#+options: tex:t toc:nil\n#+startup: inlineimages latexpreview\n#+filetags: :article:\n")
        :immediate-finish t
        :unnarrowed t)))
#+end_src
*** Define the Type of a Node

It can be useful to differentiate the different types of zettels at completion time.

#+begin_src emacs-lisp :tangle "lisp/org-roam-config.el" :mkdirp yes
  (with-eval-after-load 'org-roam
    (cl-defmethod org-roam-node-type ((node org-roam-node))
      "Return the TYPE of NODE."
      (condition-case nil
          (file-name-nondirectory
           (directory-file-name
            (file-name-directory
             (file-relative-name
              (org-roam-node-file node)
              org-roam-directory))))
        (error "")))
    )
#+end_src

*** Modifying Display Template to Show Node Type

#+begin_src emacs-lisp :tangle "lisp/org-roam-config.el" :mkdirp yes
  (setq org-roam-node-display-template
        (concat "${type:15} ${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
#+end_src

** Org Roam UI Frontend
[[https://github.com/org-roam/org-roam-ui][org-roam-ui]] is a graphical frontend for displaying org roam nodes in a graph-like interface.

#+begin_src emacs-lisp :tangle "lisp/org-roam-config.el" :mkdirp yes
  (use-package websocket
    :after org-roam)

  (use-package org-roam-ui
    :after org-roam
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-default-view '2d
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))

  (ns/leader-spc
    "ng" '(org-roam-ui-mode :wk "org roam ui graph"))
#+end_src
* Development

** LSP
*** lsp-mode
[[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]] enables IDE-like functionality for many different programming languages via "language servers" that speak the [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]].  Before trying to set up =lsp-mode= for a particular language, check out the [[https://emacs-lsp.github.io/lsp-mode/page/languages/][documentation for your language]] so that you can learn which language servers are available and how to install them.

The =lsp-keymap-prefix= setting enables you to define a prefix for where =lsp-mode='s default keybindings will be added.  I *highly recommend* using the prefix to find out what you can do with =lsp-mode= in a buffer.

The =which-key= integration adds helpful descriptions of the various keys so you should be able to learn a lot just by pressing =C-c l= in a =lsp-mode= buffer and trying different things that you find there.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes

#+end_src

*** Eglot
#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (defun ns/prog-mode-setup ()
    "Setup some sensible defaults."
    (setq truncate-lines t) ; Avoid code wrap.
    (display-fill-column-indicator-mode 1) ; Show fill column (already set to 80).
    (flymake-mode 1) ; Basic syntax checking.
    )

  (use-package eglot
    :hook
    (prog-mode . ns/prog-mode-setup)
    (eglot-managed-mode . eglot-inlay-hints-mode)
    ((c-mode
      c++-mode
      csharp-mode
      python-mode
      rust-mode
      yaml-mode
      ) . eglot-ensure)
    :config
    ;; (setq eglot-stay-out-of '(flymake))

    ;; Optional: improve eldoc display
    (setq eldoc-echo-area-use-multiline-p t)

    (setq eglot-autoshutdown t                ; Shutdown servers when last buffer closes
          eglot-sync-connect nil              ; Connect asynchronously
          eglot-events-buffer-size 0          ; Disable noisy *eglot-events* logging
          eglot-ignored-server-capabilities
          '(:documentHighlightProvider        ; Don’t auto-highlight symbol under point
            :documentOnTypeFormattingProvider ; Avoid intrusive on-type formatting
            :inlayHintProvider))
    ;; Use header line for breadcrumbs (like VSCode symbol path)
    (setq eglot-display-context 'header-line)
    )

  ;; TODO: Convert these keybinds to eglot.
  ;; (ns/leader-m 'lsp-mode-map
  ;;  "a" 'lsp-execute-code-action
  ;;  "v" 'lsp-avy-lens
  ;;  "n" 'lsp-describe-thing-at-point
  ;;  ;; "i" 'lsp-goto-implementation
  ;;  "d" 'lsp-find-definition
  ;;  "D" 'lsp-find-declaration
  ;;  "t" 'lsp-find-type-definition
  ;;  "x" 'lsp-find-references
  ;;  "r" 'lsp-rename
  ;;  "R" 'lsp-restart-workspace
  ;;  "=" 'lsp-format-buffer
  ;;  "l" 'lsp-workspace-show-log)
#+end_src

*** consult-eglot
#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package consult-eglot
    :after (consult eglot)
    :bind (:map eglot-mode-map
           ("C-c l d" . consult-eglot-symbols)))
#+end_src

** Debugging with dap-mode
[[https://emacs-lsp.github.io/dap-mode/][dap-mode]] is an excellent package for bringing rich debugging capabilities to Emacs via the [[https://microsoft.github.io/debug-adapter-protocol/][Debug Adapter Protocol]].  You should check out the [[https://emacs-lsp.github.io/dap-mode/page/configuration/][configuration docs]] to learn how to configure the debugger for your language.  Also make sure to check out the documentation for the debug adapter to see what configuration parameters are available to use for your debug templates!

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package dap-mode
    :after eglot-mode
    :config
    (dap-mode 1)
    (dap-ui-mode 1)
    (dap-tooltip-mode 1))
#+end_src

** TRAMP Mode
TRAMP (Transparent remote access, multiple protocols) allows users to edit remote files.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  ;; Setup TRAMP mode
  (setq tramp-default-method "ssh")
#+end_src

** Yasnippet
A template system for Emacs.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package yasnippet
    :disabled t
    :general
    (ns/leader-ct 'override
      "Y" #'yas-new-snippet)
    :config
    ;; Don't expand snippets in normal mode
    (general-def 'normal yas-minor-mode-map
      [remap yas-expand] #'ignore)
    (general-def input-decode-map "C-i" [C-i])
    (general-def 'insert yas-minor-mode-map
      "<C-i>" #'yas-expand))
#+end_src

*** Extra Snippets
#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package yasnippet-snippets
    :disabled t
    :after yasnippet
    :demand t
    :config
    ;; Necessary for my personal snippets to override some of these
  (yas-reload-all))
#+end_src

*** Consult Yasnippet
A better ~yas-insert-snippet~.
#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package consult-yasnippet
    :disabled t
    :general ('insert "C-<tab>" #'consult-yasnippet))
#+end_src

** Projectile
[[https://projectile.mx/][Projectile]] is a project management library for Emacs which makes it a lot easier to navigate around code projects for various languages.  Many packages integrate with Projectile so it's a good idea to have it installed even if you don't use its commands directly.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    ;; :custom ((projectile-completion-system 'ivy))
    :custom ((projectile-completion-system 'default))
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    ;; NOTE: Set this to the folder where you keep your Git repos!
    (when (file-directory-p "~/git")
      (setq projectile-project-search-path '("~/git")))
    (setq projectile-switch-project-action #'projectile-dired))

  (ns/leader-m 'override
    "p"  '(:ignore p :wk "projectile commands")
    "pf" '(projectile-find-file :wk "projectile find file")
    "ps" '(projectile-switch-project :wk "projectile switch project")
    "pg" '(consult-ripgrep :wk "consult ripgrep")
    "pp" '(projectile-find-file :wk "projectile find file")
    "pc" '(projectile-compile-project :wk "projectile compile project")
    "pd" '(projectile-dired :wk "projectile dired"))
#+end_src

** Magit
[[https://magit.vc/][Magit]] is the best Git interface I've ever used.  Common Git operations are easy to execute quickly using Magit's command panel system.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package magit
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  (use-package forge
    :after magit)

  (ns/leader-m 'override
    "g"  '(:ignore g :wk "magit commands")
    "gs" '(magit-status :wk "git status")
    "gd" '(magit-diff :wk "git diff")
    "gl " '(magit-log :wk "git log")
    ;; Pushing and pulling
    "gk " '(magit-push :wk "git push")
    "gj " '(magit-pull  :wk "git pull")
    "gc " '(magit-commit :wk "git commit")
    "ga " '(magit-stage :wk "git add")
    "gi " '(magit-init :wk "git init"))
#+end_src

** Forge
Forge allows use to work with varios git forges using the magit interface.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
  (use-package forge
    :after 'magit)
#+end_src

** Flymake
#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
    ;; (defun ns/flymake-cc-default ()
    ;;   "Default compile command for C++ files without a Makefile."
    ;;   (if buffer-file-name
    ;;       (let (
    ;;             (base-name  (file-name-sans-extension (file-name-nondirectory buffer-file-name))))
    ;;         (concat "g++ --std=c++23 -g -o "
    ;;                 base-name
    ;;                 " " base-name ".cpp"
    ;;                 " && ./" base-name))
    ;;         (message "Buffer is not visiting a file")))

    ;; (use-package flymake
    ;;   :hook (c++-mode . flymake-mode)
    ;;   :custom
    ;;   ;; Automatically continue without needing to hit Enter
    ;;   (compilation-read-command nil)
    ;;   :config
    ;;   (setq-default compile-command '(ns/flymake-cc-default))
    ;;   )

    ;; (general-def '(normal insert visual)
    ;;   :keymaps 'c++-mode-map
    ;;   "C-c C-c" 'compile)
#+end_src

** Rainbow Delimiters
[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] is useful in programming modes because it colorizes nested parentheses and brackets according to their nesting depth.  This makes it a lot easier to visually match parentheses in Emacs Lisp code without having to count them yourself.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package rainbow-delimiters
    :hook
    (prog-mode . rainbow-delimiters-mode)
    (org-mode . rainbow-delimiters-mode)
    (lisp-mode . rainbow-delimiters-mode))
#+end_src

** Smartparens
[[https://github.com/Fuco1/smartparens][Smartparens]] is a minor mode for dealing with pairs in Emacs.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package smartparens
    :init
    (smartparens-global-mode)
    :config
    ;; load default config
    (require 'smartparens-config))
#+end_src


* Programming Languages
** C/C++

#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes
  (use-package ccls
    :custom
    (ccls-executable "ccls"))
#+end_src

** Common Lisp

#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes
  ;; Load SLY
  ;; (require 'sly)
  ;; Set the Common Lisp implementation to SBCL
  ;; (setq inferior-lisp-program "/usr/bin/sbcl")

  ;; (add-to-list 'sly-contribs 'sly-asdf 'append)

#+end_src

** Go
#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes
  (use-package go-mode
    :hook
    (go-mode . lsp-deferred))
#+end_src

** Guile
Setup for guile scheme development.
#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp
  (use-package geiser
    :config
    (setq geiser-active-implementations '(guile)))

  (use-package geiser-guile)
#+end_src

** Python
We use =lsp-mode= and =dap-mode= to provide a more complete development environment for Python in Emacs.  Check out [[https://emacs-lsp.github.io/lsp-mode/page/lsp-pyls/][the =pyls= configuration]] in the =lsp-mode= documentation for more details.

Make sure you have the =pyls= language server installed before trying =lsp-mode=!

#+begin_src sh :tangle no

pip install --user "python-language-server[all]"

#+end_src

There are a number of other language servers for Python so if you find that =pyls= doesn't work for you, consult the =lsp-mode= [[https://emacs-lsp.github.io/lsp-mode/page/languages/][language configuration documentation]] to try the others!

#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes
  (use-package python-mode
    :hook (python-mode . lsp-deferred)
    :custom
    (lsp-pyls-server-command '("/home/nick/.local/lib/python3.10/site-packages/pyls
  "))
    ;; NOTE: Set these if Python 3 is called "python3" on your system!
    ;; (python-shell-interpreter "python3")
    ;; (dap-python-executable "python3")
    (dap-python-debugger 'debugpy)
    :config
    (setq-default python-indent-offset 4))
#+end_src

You can use the pyvenv package to use =virtualenv= environments in Emacs.  The =pyvenv-activate= command should configure Emacs to cause =lsp-mode= and =dap-mode= to use the virtual environment when they are loaded, just select the path to your virtual environment before loading your project.

#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes

  ;; (use-package pyvenv
  ;;   :after python-mode
  ;;   :config
  ;;   (pyvenv-mode 1))

#+end_src

** Rust
#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes
  (use-package rust-mode
    :hook
    (rust-mode . lsp-deferred))
#+end_src

* Terminals
** term-mode

=term-mode= is a built-in terminal emulator in Emacs.  Because it is written in Emacs Lisp, you can start using it immediately with very little configuration.  If you are on Linux or macOS, =term-mode= is a great choice to get started because it supports fairly complex terminal applications (=htop=, =vim=, etc) and works pretty reliably.  However, because it is written in Emacs Lisp, it can be slower than other options like =vterm=.  The speed will only be an issue if you regularly run console apps with a lot of output.

One important thing to understand is =line-mode= versus =char-mode=.  =line-mode= enables you to use normal Emacs keybindings while moving around in the terminal buffer while =char-mode= sends most of your keypresses to the underlying terminal.  While using =term-mode=, you will want to be in =char-mode= for any terminal applications that have their own keybindings.  If you're just in your usual shell, =line-mode= is sufficient and feels more integrated with Emacs.

With =evil-collection= installed, you will automatically switch to =char-mode= when you enter Evil's insert mode (press =i=).  You will automatically be switched back to =line-mode= when you enter Evil's normal mode (press =ESC=).

Run a terminal with =M-x term!=

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =C-c C-k= - Enter char-mode
- =C-c C-j= - Return to line-mode
- If you have =evil-collection= installed, =term-mode= will enter char mode when you use Evil's Insert mode

#+begin_src emacs-lisp :tangle "lisp/terminal-config.el" :mkdirp yes
  (use-package term
    :commands term
    :config
    (setq explicit-shell-file-name "bash") ;; Change this to zsh, etc
    ;;(setq explicit-zsh-args '())         ;; Use 'explicit-<shell>-args for shell-specific args

    ;; Match the default Bash shell prompt.  Update this if you have a custom prompt
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))
#+end_src

*** Better term-mode colors

The =eterm-256color= package enhances the output of =term-mode= to enable handling of a wider range of color codes so that many popular terminal applications look as you would expect them to.  Keep in mind that this package requires =ncurses= to be installed on your machine so that it has access to the =tic= program.  Most Linux distributions come with this program installed already so you may not have to do anything extra to use it.

#+begin_src emacs-lisp :tangle "lisp/terminal-config.el" :mkdirp yes
  (use-package eterm-256color
    :hook (term-mode . eterm-256color-mode))
#+end_src

** vterm

[[https://github.com/akermu/emacs-libvterm/][vterm]] is an improved terminal emulator package which uses a compiled native module to interact with the underlying terminal applications.  This enables it to be much faster than =term-mode= and to also provide a more complete terminal emulation experience.

Make sure that you have the [[https://github.com/akermu/emacs-libvterm/#requirements][necessary dependencies]] installed before trying to use =vterm= because there is a module that will need to be compiled before you can use it successfully.

#+begin_src emacs-lisp :tangle "lisp/terminal-config.el" :mkdirp yes
  (use-package vterm
    :commands vterm
    :config
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
    ;;(setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
    (setq vterm-max-scrollback 10000))
#+end_src

** shell-mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interactive-Shell.html#Interactive-Shell][shell-mode]] is a middle ground between =term-mode= and Eshell.  It is *not* a terminal emulator so more complex terminal programs will not run inside of it.  It does have much better integration with Emacs because all command input in this mode is handled by Emacs and then sent to the underlying shell once you press Enter.  This means that you can use =evil-mode='s editing motions on the command line, unlike in the terminal emulator modes above.

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
** Eshell

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#Contributors-to-Eshell][Eshell]] is Emacs' own shell implementation written in Emacs Lisp.  It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (=ls=, =rm=, =mv=, =grep=, etc).  It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing =vim= to =find-file=).  Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don't work as well.  However, many of these limitations can be dealt with by good configuration and installing external packages, so don't let that discourage you from trying it!

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor

We will be covering Eshell more in future videos highlighting other things you can do with it.

For more thoughts on Eshell, check out these articles by Pierre Neidhardt:
- https://ambrevar.xyz/emacs-eshell/index.html
- https://ambrevar.xyz/emacs-eshell-versus-shell/index.html

#+begin_src emacs-lisp :tangle "lisp/terminal-config.el" :mkdirp yes
  (defun efs/configure-eshell ()
    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Bind some useful keys for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
    (evil-normalize-keymaps)

    (setq eshell-history-size         10000
          eshell-buffer-maximum-lines 10000
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t))

  (use-package eshell-git-prompt
    :after eshell)

  (use-package eshell
    :hook (eshell-first-time-mode . efs/configure-eshell)
    :config

    (with-eval-after-load 'esh-opt
      (setq eshell-destroy-buffer-when-process-dies t)
      (setq eshell-visual-commands '("htop" "zsh" "vim")))

    (eshell-git-prompt-use-theme 'powerline))
#+end_src

* Applications
** Elfeed

#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
  (use-package elfeed
    :commands elfeed
    :config
    (setq elfeed-feeds rss-feeds))
  ;; (add-hook 'elfeed-new-entry-hook
  ;;           (elfeed-make-tagger :feed-url "youtube\\.com"
  ;; :add '(video youtube)))
#+end_src
** IRC
=rcirc= is an IRC client for Emacs.
#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
  (use-package rcirc
    :custom
    (rcirc-default-nick "nshan651")
    (rcirc-default-user-name "nshan651")
    (rcirc-default-full-name "ns")
    (rcirc-server-alist '(
                          ("irc.libera.chat"
  			             :channels ("#emacs" "#guix")
                           :port 6697
                           :encryption tls
                           )))
    (rcirc-prompt "%t> ")
    (rcirc-timeout-seconds most-positive-fixnum)

    (rcirc-reconnect-delay 5)
    (rcirc-fill-column 90)
    (rcirc-track-ignore-server-buffer-flag t))
  #+end_src

To register a nickname,

** Ox-hugo
Website publishing.

#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
(use-package ox-hugo
  :after ox)
#+end_src
** Org-caldav
Calendar syncing using the =caldav= protocol.
#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
  (use-package org-caldav
    :custom
    ;; URL of the caldav server
    (org-caldav-url
     "http://nextcloud.nshan651.duckdns.org/nextcloud/remote.php/dav/calendars/nshan651")

    ;; calendar ID on server
    (org-caldav-calendar-id "personal")

    ;; Org filename where new entries from calendar stored
    (org-caldav-inbox "~/ark/org/agenda/todo.org")

    ;; Additional Org files to check for calendar events
    (org-caldav-files nil)

    ;; Usually a good idea to set the timezone manually
    (org-icalendar-timezone "America/Chicago")

    ;; TODO
    (org-caldav-sync-todo t)
    (org-caldav-todo-deadline-schedule-warning-days t)

    (org-icalendar-include-todo 'all)
    ;; (org-icalendar-use-deadline 'todo-due)
    ;; (org-icalendar-use-scheduled 'todo-start)
    (org-icalendar-use-deadline '(event-if-todo event-if-not-todo todo-due))
    (org-icalendar-use-scheduled '(event-if-todo event-if-not-todo todo-start))
    (org-icalendar-with-timestamps t)
  )
#+end_src
** Guix
The Gnu Guix interface.
#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
  ;; (use-package guix)
#+end_src
** GPTel
[[https://github.com/karthink/gptel][gptel]] is a simple llm interface for emacs. I have multiple backends to choose from, including [[https://github.com/ollama/ollama][Ollama]], openrouter, groq, and gemini.

#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
  (use-package gptel
    :custom
    (gptel-default-mode 'org-mode)
    (gptel-model 'moonshotai/kimi-k2-instruct)
    :config

    ;; Set up model backends.
    (setq ns/gptel-ollama-backend (gptel-make-ollama "shodan"
                                    :host "shodan:11434" ;; Or use shodan.local for mDNS.
                                    :stream t
                                    :models '(deepseek-r1:1.5b-ns
                                              gemma3:1b
                                              gemma3:latest
                                              llama3.2:latest
                                              llama3.2-ns
                                              qwen3:1.7b-ns
                                              qwen3:1.7b
                                              qwen3:4b-ns)))

    (setq ns/gptel-openrouter-backend
          (gptel-make-openai "openrouter"
            :host "openrouter.ai"
            :endpoint "/api/v1/chat/completions"
            :stream t
            :key (lambda () (auth-source-pass-get 'secret "openrouter/key"))
            :models '(deepseek/deepseek-chat-v3.1:free
                      openai/gpt-oss-20b:free
                      qwen/qwen3-coder:free
                      moonshotai/kimi-k2:free
                      )))

    (setq ns/gptel-groq-backend
          (gptel-make-openai "groq"
            :host "api.groq.com"
            :endpoint "/openai/v1/chat/completions"
            :stream t
            :key (lambda () (auth-source-pass-get 'secret "groq/key"))
            :models '(moonshotai/kimi-k2-instruct
                      openai/gpt-oss-120b
                      llama-3.1-70b-versatile
                      qwen/qwen3-32b
                      openai/gpt-oss-20b)))

    (setq ns/gptel-gemini-backend
          (gptel-make-gemini "gemini"
            :stream t
            :key (lambda () (auth-source-pass-get 'secret "gemini/key"))
            :models '(gemini-2.5-flash
                      gemini-2.0-flash-lite
                      (gemini-2.5-pro
                       :description
                       "Complex reasoning tasks, problem solving and data extraction"
                       :capabilities (tool json)
                       :mime-types
                       ("image/jpeg" "image/png" "image/webp" "image/heic")))))


    ;; Set the defualt model backend.
    (setq gptel-backend ns/gptel-groq-backend)

    ;; Configure system prompts.
    (gptel-make-preset "Incremental Reasoning"
      :system-message "Let's think step by step to assure we arrive at the correct answer."
      :backend      "groq"
      :model        'moonshotai/kimi-k2-instruct)

    (gptel-make-preset 'proofreader
      :description "Preset for proofreading tasks."
      :backend "gemini"
      :model 'gemini-2.0-flash
      :tools '("read_buffer" "spell_check" "grammar_check")
      :temperature 0.7
      :use-context 'system)

    (gptel-make-preset 'websearch
      :description  "gemini with basic web search capability."
      :backend      "gemini"
      :model        'gemini-2.5-flash
      :tools        '("search_web" "read_url" "get_youtube_meta"))

    (gptel-make-preset 'resume
      :system-message "Use the following resume to answer interview questions in a thoughtful way."
      :backend "shodan"
      :pre (lambda () (gptel-add-file "~/git/interviews/resume.org")))
    )

  (defun ns/gptel-select-backend ()
    "Select a gptel backend and update `gptel-backend`."
    (interactive)
    (let* ((backends '(("shodan" . ns/gptel-ollama-backend)
                       ("openrouter" . ns/gptel-openrouter-backend)
                       ("groq" . ns/gptel-groq-backend)
                       ("gemini" . ns/gptel-gemini-backend)
                       ))
           (choice (completing-read "Select gptel backend: " (mapcar #'car backends)))
           (backend (cdr (assoc choice backends))))
      (when backend
        (setq gptel-backend (symbol-value backend))
        (message "gptel backend set to: %s" choice))))

  (defun ns/quickdraw (prompt)
    (gptel-request prompt
      :callback
      (lambda (response info)
        (when response
          (with-current-buffer (get-buffer-create "*quickdraw*")
            (org-mode)
            (goto-char (point-max))
            (unless (bobp)
              (insert (format "\n\n")))
            (insert (format "* %s\n" (format-time-string "%F %T")))
            (insert response)
            (display-buffer (current-buffer)))))))

  (defun ns/quickdraw-selection ()
    "Quick analysis of selected region, results go to *quickdraw* buffer."
    (interactive)
    (unless (region-active-p)
      (user-error "No region selected"))
    (let* ((selected-text (buffer-substring-no-properties (region-beginning) (region-end)))
           (prompt (format "Provide a quick, concise explanation of the following:\n%s" selected-text)))
      (ns/quickdraw prompt)
      ))

  (defun ns/quickdraw-prompt ()
    "Send a prompt from minibuffer to *quickdraw* buffer."
    (interactive)
    (let ((prompt (read-string "Quickdraw: ")))
      (when (string-empty-p prompt)
        (user-error "Empty prompt"))
      (ns/quickdraw prompt)
      ))

  (with-eval-after-load 'evil
    (keymap-set evil-visual-state-map "C-c q" #'ns/quickdraw-selection)
    (keymap-global-set "C-c q" #'ns/quickdraw-prompt))

  ;; Gptel keyboard shortcuts.
  (ns/leader-comma
    "b" '(gptel-abort :wk "gptel abort")
    "g" '(gptel-mode :wk "gptel mode")
    "p" '(gptel :wk "gptel prompt")
    "r" '(gptel-rewrite :wk "gptel rewrite")
    "s" '(gptel-send :wk "gptel send")
    "m" '(gptel-menu :wk "gptel menu")
    "a" '(gptel-add :wk "gptel add")
    "f" '(gptel-add-file :wk "gptel add file"))

  ;; (ns/leader-spc
  ;;   "g"  '(:ignore t :wk "gptel")
  ;;   "gb" '(gptel-abort :wk "gptel abort")
  ;;   "gg" '(gptel-mode :wk "gptel mode")
  ;;   "gp" '(gptel :wk "gptel prompt")
  ;;   "gr" '(gptel-rewrite :wk "gptel rewrite")
  ;;   "gs" '(gptel-send :wk "gptel send")
  ;;   "gm" '(gptel-menu :wk "gptel menu")
  ;;   "ga" '(gptel-add :wk "gptel add")
  ;;   "gf" '(gptel-add-file :wk "gptel add file"))
#+end_src

** Setup Instructions
We will configure Ollama to listen on all local network interfaces. Start editing the systemd unit with the command ~sudo systemctl edit ollama.service~ and adding the following:

#+begin_src sh
  [Unit]
  After=network-online.target avahi-daemon.service
  Wants=network-online.target avahi-daemon.service

  [Service]
  Environment="OLLAMA_HOST=0.0.0.0"
#+end_src

Allow port =11434= on your operating system's firewall. Then, use the following curl command on another device to ensure that you can reach the host:

#+begin_src sh
  # Replace with `localhost` if on the Ollama server.
  curl http://shodan:11434/api/chat -d '{
    "model": "llama3.2",
    "messages": [
      { "role": "user", "content": "why is the sky blue?" }
    ]
  }'
#+end_src

* Window Management

** Perspective
#+begin_src emacs-lisp :tangle "lisp/window-config.el" :mkdirp yes
  (use-package perspective
    :custom
    (persp-initial-frame-name "main")
    (persp-mode-prefix-key (kbd "C-a"))
    :init
    (unless (equal persp-mode t)
      (persp-mode)))

  (ns/leader-ca 'persp-mode-map
    "s"  '(persp-switch :wk "query or create persp")
    "k"  '(persp-kill :wk "kill a persp")
    "r"  '(persp-rename :wk "rename a persp")
    ;; Buffer management
    "a"  '(persp-add-buffer :wk "add buffer to current persp")
    "A"  '(persp-set-buffer :wk "add buffer to current persp, remove from others")
    "b"  '(persp-switch-to-buffer :wk "switch to buffer, global by default")
    ;; Switch perspectives
    "n"  '(persp-next :wk "next persp")
    "p"  '(persp-prev :wk "previous persp")
    ;; Merging and importing
    "m"  '(persp-merge :wk "merge buffers into another persp")
    "u"  '(persp-unmerge :wk "undo effects of `persp-merge'")
    "i"  '(persp-import :wk "import a given perspective from another frame")
    ;; Save and load perspectives
    "C-s"  '(persp-state-save :wk "Save all persps in all frames to a file")
    "C-l"  '(persp-state-load :wk "load all persps from a file")
  )
 #+end_src

** Popper
#+begin_src emacs-lisp :tangle "lisp/window-config.el" :mkdirp yes
  (use-package popper
    :init
    (setq popper-reference-buffers
          '("\\*\\*Messages"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            help-mode
            compilation-mode))
    (popper-mode 1)
    (popper-echo-mode 1))                ; For echo area hints

  (general-def 'override
    "C-`" '(popper-toggle :wk "toggle popup")
    "M-`" '(popper-cycle :wk "cycle through popups")
    "C-M-`" '(popper-toggle-type :wk "change current buffer's toggle type"))

#+end_src

* File Management
** Dired

Dired is a built-in file manager for Emacs that does some pretty amazing things!  Here are some key bindings you should try out:

*** Key Bindings
**** Navigation

*Emacs* / *Evil*
- =n= / =j= - next line
- =p= / =k= - previous line
- =j= / =J= - jump to file in buffer
- =RET= - select file or directory
- =^= - go to parent directory
- =S-RET= / =g O= - Open file in "" window
- =M-RET= - Show file in other window without focusing (previewing files)
- =g o= (=dired-view-file=) - Open file but in a "preview" mode, close with =q=
- =g= / =g r= Refresh the buffer with =revert-buffer= after changing configuration (and after filesystem changes!)

**** Marking files

- =m= - Marks a file
- =u= - Unmarks a file
- =U= - Unmarks all files in buffer
- =* t= / =t= - Inverts marked files in buffer
- =% m= - Mark files in buffer using regular expression
- =*= - Lots of other auto-marking functions
- =k= / =K= - "Kill" marked items (refresh buffer with =g= / =g r= to get them back)
- Many operations can be done on a single file if there are no active marks!

**** Copying and Renaming files

- =C= - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- =U= - Unmark all files in buffer
- =R= - Rename marked files, renaming multiple is a move!
- =% R= - Rename based on regular expression: =^test= , =old-\&=

*Power command*: =C-x C-q= (=dired-toggle-read-only=) - Makes all file names in the buffer editable directly to rename them!  Press =Z Z= to confirm renaming or =Z Q= to abort.

**** Deleting files

- =D= - Delete marked file
- =d= - Mark file for deletion
- =x= - Execute deletion for marks
- =delete-by-moving-to-trash= - Move to trash instead of deleting permanently

***** Creating and extracting archives

- =Z= - Compress or uncompress a file or folder to (=.tar.gz=)
- =c= - Compress selection to a specific file
- =dired-compress-files-alist= - Bind compression commands to file extension

***** Other common operations

- =T= - Touch (change timestamp)
- =M= - Change file mode
- =O= - Change file owner
- =G= - Change file group
- =S= - Create a symbolic link to this file
- =L= - Load an Emacs Lisp file into Emacs


*** Configuration

#+begin_src emacs-lisp :tangle "lisp/dired-config.el" :mkdirp yes
  (use-package dired
    :ensure nil
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump))
    :custom ((dired-listing-switches "-agho --group-directories-first"))
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "h" 'dired-single-up-directory
      "l" 'dired-single-buffer))

  (use-package dired-single
    :commands (dired dired-jump))

  (use-package dired-open
    :commands (dired dired-jump)
    :config
    ;; Doesn't work as expected!
    ;;(add-to-list 'dired-open-functions #'dired-open-xdg t)
    (setq dired-open-extensions '(("png" . "feh")
                                  ("mkv" . "mpv"))))
#+end_src
