#+title: GNU Emacs Config
#+author: nshan651

* Introduction
My config was heavily inspired by David Wilson's [[https://github.com/daviwil/emacs-from-scratch/blob/master/Emacs.org][emacs-from-scratch]] series. Check it out! To update this, just run =C-c C-v t= or =org-babel-tangle=.

* Early Initialization
This is the first file that Emacs reads when starting up. It should contain code that does not depend on any package or the proportions of the Emacs frame. In general, this early initialization file is meant to set up a few basic things before Emacs produces the initial frame by delegating to the =init.el=.

** Macros to run code only in a Desktop Environment
#+begin_src emacs-lisp :tangle "early-init.el"
  (defvar ns-emacs-tiling-window-manager-regexp
    (regexp-opt '("bspwm" "i3" "dwm"))
    "Regular expression to  tiling window managers.
  See definition of `ns-emacs-with-desktop-session'.")

  (defmacro ns-emacs-with-desktop-session (&rest body)
   "Expand BODY if desktop session is not a tiling window manager.
  See `ns-emacs-tiling-window-manager-regexp' for what
  constitutes a matching tiling window manager."
    (declare (indent 0))
    `(when-let ((session (getenv "DESKTOP_SESSION"))
                ((not (string-match-p session ns-emacs-tiling-window-manager-regexp))))
       ,@body))
#+end_src

** Set frame parameters
Here I am setting parameters for the size of the Emacs frame: the first as well as any future one. In a tiling window manager, these parameters are not relevant, since all windows are forcibly made to fit into rectangles (tiles) that fill up the entire screen. So I use the ns-emacs-with-desktop-session macro that I described above to set these parameters only when I am in a regular desktop environment (The early-init.el macro to run code only in a Desktop Environment).

#+begin_src emacs-lisp :tangle "early-init.el"
  (defun ns-emacs-add-to-list (list element)
    "Add to symbol of LIST the given ELEMENT.
  Simplified version of `add-to-list'."
    (set list (cons element (symbol-value list))))

  (ns-emacs-with-desktop-session
    (mapc
     (lambda (var)
       (ns-emacs-add-to-list var '(width . (text-pixels . 900)))
       (ns-emacs-add-to-list var '(height . (text-pixels . 600)))
       (ns-emacs-add-to-list var '(scroll-bar-width  . 10)))
     '(default-frame-alist initial-frame-alist)))
#+end_src

** Basic frame settings
These are general frame settngs. Notice the frame-resize-pixelwise and frame-inhibit-implied-resize: by default Emacs will resize the frame if you adjust the font size, which I never want.

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq frame-resize-pixelwise t
        frame-inhibit-implied-resize t
        frame-title-format '("%b")
        ring-bell-function 'ignore
        use-dialog-box t ; only for mouse events, which I seldom use
        use-file-dialog nil
        use-short-answers t
        inhibit-splash-screen t
        inhibit-startup-screen t
        inhibit-startup-message t
        initial-scratch-message nil
        inhibit-x-resources t
        inhibit-startup-echo-area-message user-login-name ; read the docstring
        inhibit-startup-buffer-menu t)

  (set-fringe-mode 10) ; Give some breathing room

  (menu-bar-mode -1)   ; Disable the menu bar

  ;; Disable graphical elements
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)

  ;; Default for fill column should be 80 (not 70 like emacs would have it!!!)
  (setq-default fill-column 80)

  ;; Set frame transparency
  (set-frame-parameter (selected-frame) 'alpha '(100. 100))
  (add-to-list 'default-frame-alist `(alpha . (100 . 100)))
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

** Improve scrolling

#+begin_src emacs-lisp :tangle "early-init.el"
  ;; Improve mouse scrolling
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse

  ;; Vim-like key scrolling
  (setq scroll-step 1
        scroll-conservatively 10000
        next-screen-context-lines 5
        ;; move by logical lines rather than visual lines (better for macros)
        line-move-visual nil)
#+end_src

#+RESULTS:

** Line Numbering

#+begin_src emacs-lisp :tangle "early-init.el"
  (column-number-mode)
  (global-display-line-numbers-mode t)
  ;; Relative line numbers
  (menu-bar--display-line-numbers-mode-relative)

  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  shell-mode-hook
                  treemacs-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

  ;; Revert Dired and other buffers
  (setq global-auto-revert-non-file-buffers t)

  ;; Revert buffers when the underlying file has changed
  (global-auto-revert-mode 1)
#+end_src

#+RESULTS:
: t

** Garabage collection
Here we maximize the GC threshold to make Emacs boot a bit faster.

#+begin_src emacs-lisp :tangle "early-init.el"
;; Temporarily increase the garbage collection threshold.  These
;; changes help shave off about half a second of startup time.  The
;; `most-positive-fixnum' is DANGEROUS AS A PERMANENT VALUE.  See the
;; `emacs-startup-hook' a few lines below for what I actually use.
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.5)

;; Same idea as above for the `file-name-handler-alist' and the
;; `vc-handled-backends' with regard to startup speed optimisation.
;; Here I am storing the default value with the intent of restoring it
;; via the `emacs-startup-hook'.
(defvar ns-emacs--file-name-handler-alist file-name-handler-alist)
(defvar ns-emacs--vc-handled-backends vc-handled-backends)

(setq file-name-handler-alist nil
      vc-handled-backends nil)

(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold (* 1024 1024 20)
                  gc-cons-percentage 0.2
                  file-name-handler-alist ns-emacs--file-name-handler-alist
                  vc-handled-backends ns-emacs--vc-handled-backends)))
#+end_src

** Declare all themes as safe

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq custom-safe-themes t)
#+end_src

** Initialize the package cache
I use the standard package.el.

#+begin_src emacs-lisp :tangle "early-init.el"
;; Initialise installed packages at this early stage, by using the
;; available cache.  I had tried a setup with this set to nil in the
;; early-init.el, but (i) it ended up being slower and (ii) various
;; package commands, like `describe-package', did not have an index of
;; packages to work with, requiring a `package-refresh-contents'.
(setq package-enable-at-startup t)
#+end_src

** Give a name to the default frame

Finally, I like to call my default frame home. This is because I use my beframe package to group the list of buffers on a per-frame basis.

#+begin_src emacs-lisp :tangle "early-init.el"
(add-hook 'after-init-hook (lambda () (set-frame-name "home")))
#+end_src

* Init Configuration
** Disable backups and lockfiles

#+begin_src emacs-lisp :tangle "init.el"
(setq make-backup-files nil)
(setq backup-inhibited nil) ; Not sure if needed, given `make-backup-files'
(setq create-lockfiles nil)
#+end_src

** Make native compilation silent

#+begin_src emacs-lisp :tangle "init.el"
;; Make native compilation silent and prune its cache.
(when (native-comp-available-p)
  (setq native-comp-async-report-warnings-errors 'silent) ; Emacs 28 with native compilation
  (setq native-compile-prune-cache t)) ; Emacs 29
#+end_src

** Send custom-file to the shadow realm

By default, Emacs writes persistent customisations to the end of the user’s init file. These are encapsulated in a “custom” block. Emacs writes those whenever the user does something with M-x customize or related.

I personally prefer writing the actual Elisp over using the interface of M-x customize. I also want my init file to only ever contain what I wrote and to never—ever!—evaluate code I have not called myself.

#+begin_src emacs-lisp :tangle "init.el"
;; Disable the damn thing by making it disposable.
(setq custom-file (make-temp-file "emacs-custom-"))
#+end_src

** Enable and disable certain commands
Some Emacs commands are disabled by default. This means that Emacs will produce a warning when we try to invoke them and will ask us for confirmation. Here I define which commands I want to have enabled and then put some on the disabled list.

#+begin_src emacs-lisp :tangle "init.el"
;; Enable these
(mapc
 (lambda (command)
   (put command 'disabled nil))
 '(list-timers narrow-to-region narrow-to-page upcase-region downcase-region))

;; And disable these
(mapc
 (lambda (command)
   (put command 'disabled t))
 '(eshell project-eshell overwrite-mode iconify-frame diary))
#+end_src

** Start with the =*scratch*= buffer
Keep it simple. I have this disabled by default.

#+begin_src emacs-lisp :tangle "init.el"
;; Always start with *scratch*
;;(setq initial-buffer-choice t)
#+end_src

** Pre-load package configs in =lisp= directory

#+begin_src emacs-lisp :tangle "init.el"
  ;; Load my lisp package config paths
  (mapc
  (lambda (string)
    (add-to-list 'load-path (locate-user-emacs-file string)))
    '("lisp"))

  (defun ns/load-lisp-config (file-list)
    "Loads all config files in lisp directory."
    (dolist (file file-list)
    (let ((full-path (locate-user-emacs-file (concat "lisp/" file))))
    (when (file-readable-p full-path)
    (load full-path)))))

    ;; Load paths in specific order
      (let ((file-list
        '("evil-config.el"
          "theme-config.el"
          "development-config.el"
          "ui-config.el"
          "org-config.el"
          "org-roam-config.el"
          "programming-languages-config.el"
          "terminal-config.el"
          "applications-config.el"
          "window-config.el"
          "dired-config.el")))

  (ns/load-lisp-config file-list))

  ;;Also load my `org-templates.el' and `feed.el'
  ;; (load (locate-user-emacs-file "etc/org-templates.el"))
  (load (locate-user-emacs-file "etc/feed.el"))
#+end_src

#+RESULTS:
: t

** Package Setup
Setup package archives for =package.el=.

#+begin_src emacs-lisp :tangle "init.el"
  ;;;; Packages

  (require 'package)

  (setq package-vc-register-as-project nil) ; Emacs 30

  (add-hook 'package-menu-mode-hook #'hl-line-mode)

  (setq package-archives
        '(("elpa" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))

  ;; Highest number gets priority (what is not mentioned has priority 0)
  (setq package-archive-priorities
        '(("elpa" . 2)
          ("melpa" . 1)))
#+end_src

** Load Some Basic Packages
These are just some nice packages to have around.

*** Async
Provides asynchronous bytecode compilation and various other actions.

#+begin_src emacs-lisp :tangle "init.el" :mkdirp yes
  (use-package async
    :defer t
    :init
    (dired-async-mode 1))
#+end_src

*** Savehist
Persist history over Emacs restarts. Vertico sorts by history position.

#+begin_src emacs-lisp :tangle "init.el" :mkdirp yes
  (use-package savehist
    :init
    (setq history-length 25)
    (savehist-mode t))
#+end_src

#+RESULTS:

*** Repeat

#+begin_src emacs-lisp :tangle "init.el" :mkdirp yes
  (use-package repeat
    :defer 10
    :init
    (repeat-mode +1))
#+end_src

*** Clean Whitespaces
Automatically trim extraneous whitespaces.

#+begin_src emacs-lisp :tangle "init.el" :mkdirp yes
(use-package ws-butler
  :config
  (ws-butler-global-mode 1))
#+end_src

** Clipboard
#+begin_src emacs-lisp :tangle "init.el" :mkdirp yes
  (setq select-enable-clipboard t)
  (setq x-select-enable-clipboard t)

  (global-set-key (kbd "C-S-c") 'copy-region-as-kill)
  (global-set-key (kbd "C-S-v") 'yank)
#+end_src

#+RESULTS:
: yank

* Keybindings
All my keybindings are controlled by evil mode.

** Evil Keybindings
Load my custom keybindings.

#+begin_src emacs-lisp :tangle "lisp/evil-config.el" :mkdirp yes
  ;; Bind C-x C-b to ibuffer
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  ;; Make ESC quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    (setq evil-respect-visual-line-mode t)
    :config
    (evil-mode 1)
    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))
#+end_src

** Evil Collection
Evil collection adds some additional compatability to modes that otherwise don't play well with evil-mode.

#+begin_src emacs-lisp :tangle "lisp/evil-config.el" :mkdirp yes
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

** General
General is the best method that I've found for organizing keybindings.

#+begin_src emacs-lisp :tangle "lisp/evil-config.el" :mkdirp yes
  (use-package general
    :after evil
    :config
    ;; Create definer keys to map keys with
    (general-create-definer ns/leader-spc
      :states 'normal
      :keymaps 'override
      :prefix "SPC")
    (general-create-definer ns/leader-t
      :states 'normal
      :keymaps 'override
      :prefix "t")
    (general-create-definer ns/leader-r
      :states 'motion
      :prefix "r")
    (general-create-definer ns/leader-m
      :states 'normal
      :prefix "m")
    (general-create-definer ns/leader-ca
      :states 'normal
      :keymaps 'override
      :prefix "C-a")
    (general-create-definer ns/leader-ct
      :keymaps '(insert normal)
      :keymaps 'override
      :prefix "C-t")
    (general-create-definer ns/leader-comma
      :states 'normal
      :prefix ","))
#+end_src

** Basic Keybindings
These are basic keybindings that aren't tied to any particular package (except evil). I chose to group most of my keybindings by package. Personally, I find this approach makes it easier to find what I need.

#+begin_src emacs-lisp :tangle "lisp/evil-config.el" :mkdirp yes
  ;; Use visual line motions even outside of visual-line-mode buffers
  (general-def 'motion
    "j" 'evil-next-visual-line
    "k" 'evil-previous-visual-line)

  ;; Choose a theme
  ;; TODO move this to consult
  (ns/leader-t
    "t" '(consult-theme :wk "Choose a theme"))

  (ns/leader-spc
    "f"  'find-file
    ;; "b"  'switch-to-buffer
    "k"  'kill-buffer
    "eb" 'eval-buffer)

  ;; Manage windows
  (ns/leader-ca 'override
    "<backspace>" 'delete-window
    "\\"          'split-window-right
    "-"           'split-window-below
    ;; Windmove keys for additional window navigation
    "h"          'windmove-left
    "l"           'windmove-right
    "k"          'windmove-up
    "j"           'windmove-down)
  ;; Window resizing
  ;; "C-h"        (lambda () (interactive) (shrink-window-horizontally 21))
  ;; "C-l"         (lambda () (interactive) (enlarge-window-horizontally 21))
  ;; "C-j"         (lambda () (interactive) (enlarge-window 11))
  ;; "C-k"        (lambda () (interactive) (shrink-window 11))

  ;; https://www.emacswiki.org/emacs/WindowResize
  (defun ns/define-x-pos ()
    "Find the window's position on the x-axis."
    (let* ((win-edges (window-edges))
           (x-min (nth 0 win-edges))
           (x-max (nth 2 win-edges))
           (max-width (+ 2 (frame-width))))
      (cond
       ((equal max-width x-max)
        "right")
       ((and (> x-min 0) (< x-max max-width))
        "mid")
       (t "left"))))

  (defun ns/win-resize-left ()
    (interactive)
    (let ((x-pos (ns/define-x-pos)))
      (cond
       ((equal "right" x-pos)
        (enlarge-window-horizontally +15))
       (t (enlarge-window-horizontally -15))
       ))
    )

  (defun ns/win-resize-right ()
    (interactive)
    (let ((x-pos (ns/define-x-pos)))
      (cond
       ((equal "right" x-pos)
        (enlarge-window-horizontally -15))
       (t (enlarge-window-horizontally +15))
       ))
    )

  (ns/leader-ca 'override
    "C-h"       (lambda () (interactive)
                  (ns/win-resize-left))
    "C-l"        (lambda () (interactive)
                   (ns/win-resize-right))
    "C-j"         (lambda () (interactive) (enlarge-window 11))
    "C-k"        (lambda () (interactive) (shrink-window 11)))

  ;; Compiling and recompiling.
  (general-def 'normal
    :prefix "g"
    "c" 'compile
    "r" 'recompile)
#+end_src

#+RESULTS:

*** Commenting
Emacs' built in commenting functionality =comment-dwim= (usually bound to =M-;=) doesn't always comment things in the way you might expect so we use [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] to provide a more familiar behavior.  I've bound it to =M-/= since other editors sometimes use this binding but you could also replace Emacs' =M-;= binding with this command.

#+begin_src emacs-lisp :tangle "lisp/evil-config.el" :mkdirp yes
  (use-package evil-nerd-commenter
    :general ("M-/" 'evilnc-comment-or-uncomment-lines))
#+end_src

#+RESULTS:

** Mouse Settings

* Theme Configuration
** Color Theme

#+begin_src emacs-lisp :tangle "lisp/theme-config.el" :mkdirp yes
  ;; modus-themes
  (use-package modus-themes)

  ;; ef-themes
  (use-package ef-themes)

  ;; Doom Themes
  (use-package doom-themes)

  ;; Set theme colors
  (defvar ns/default-theme nil)
  (defvar ns/alt-theme 'doom-one)

  ;; Load default theme
  (when ns/default-theme
    (load-theme ns/default-theme))

  (defun ns/toggle-theme (default-theme alt-theme)
    "Toggle between light and dark mode variants."
    (interactive)
    (let ((current-theme (car custom-enabled-themes)))
      ;; Disable current theme to remove vestigial highlights.
      (disable-theme current-theme)
      (if (eq default-theme current-theme)
          (load-theme alt-theme)
        (load-theme default-theme))))

  ;; Binding to toggle between default and alt theme, inspired by 'modus-themes-toggle`
  (define-key global-map (kbd "<f5>") (lambda () (interactive)
                                        (ns/toggle-theme ns/default-theme  ns/alt-theme)))
#+end_src

#+RESULTS:
: #[nil ((ns/toggle-theme ns/default-theme ns/alt-theme)) nil nil nil nil]

** Transparency

#+begin_src emacs-lisp :tangle "lisp/theme-config.el" :mkdirp yes
    (defun ns/toggle-transparency ()
      "Toggle transparency of Emacs frame."
      (interactive)
      (if (equal (car (frame-parameter (selected-frame) 'alpha)) 100)
          (set-frame-parameter (selected-frame) 'alpha '(90 . 90))
        (set-frame-parameter (selected-frame) 'alpha '(100 . 100))))

    ;; Binding to toggle between default and alt theme, inspired by 'modus-themes-toggle`
    (define-key global-map (kbd "<f4>") (lambda () (interactive)
                                          (ns/toggle-transparency)))
#+end_src

#+RESULTS:
| lambda | nil | (interactive) | (ns/toggle-transparency) |

** Font Configuration
Set font details here.

#+begin_src emacs-lisp :tangle "lisp/theme-config.el" :mkdirp yes
  ;; Set base font sizes
  (defvar efs/default-font-size 110)
  (defvar efs/default-variable-font-size 110)

  (set-face-attribute 'default nil :font "Fira Code Retina" :height efs/default-font-size)

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height efs/default-font-size)

  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil :font "Cantarell" :height
                      efs/default-variable-font-size :weight 'regular)

  ;; Nerd icon fonts
  (use-package nerd-icons
    :custom
    ;; The Nerd Font you want to use in GUI
    ;; "Symbols Nerd Font Mono" is the default and is recommended
    ;; but you can use any other Nerd Font if you want
    (nerd-icons-font-family "Symbols Nerd Font Mono"))
#+end_src

#+RESULTS:

** Modeline
I use doom modeline.

#+begin_src emacs-lisp :tangle "lisp/theme-config.el" :mkdirp yes
  (use-package doom-modeline
    :init (doom-modeline-mode 1))

  ;; Add some additional UI elements
  (display-time-mode 1)
#+end_src

#+RESULTS:
: t

** Tab Widths
#+begin_src emacs-lisp :tangle "lisp/theme-config.el" :mkdirp yes
  ;; (setq-default tab-width 2)
  ;; (setq-default evil-shift-width tab-width)
#+end_src

#+RESULTS:

* UI Enhancements
Some UI enhancements that supercharge Emacs.

** Undo System
Linear undo while maintaining all history.
#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package undo-fu
    :general
    ('normal
     "u" #'undo-fu-only-undo
     "U" #'undo-fu-only-redo
     "C-r" #'undo-fu-only-redo))

  ;; ignores encrypted files by default
  (use-package undo-fu-session
    :init (undo-fu-session-global-mode))
#+end_src

#+RESULTS:

** Which Key
[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix.  For example, if you press =C-c= (hold control and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run.  This is very useful for learning the possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package which-key
    :defer 0
    :diminish which-key-mode
    :config
    (which-key-mode)
    (setq which-key-idle-delay 1))
#+end_src

** Vertico
[[https://github.com/minad/vertico][Vertico]] provides a performant and minimalistic vertical completion UI based on the default completion system.

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
    (defun ns/minibuffer-backward-kill (arg)
    "When minibuffer is completing a file name delete up to parent
  folder, otherwise delete a character backward"
    (interactive "p")
    (if minibuffer-completing-file-name
        ;; Borrowed from https://github.com/raxod502/selectrum/issues/498#issuecomment-803283608
        (if (string-match-p "/." (minibuffer-contents))
            (zap-up-to-char (- arg) ?/)
          (delete-minibuffer-contents))
        (delete-backward-char arg)))

    ;; Enable vertico
    (use-package vertico
      :init
      (vertico-mode)
      :bind (:map minibuffer-local-map
                  ("<backspace>" . ns/minibuffer-backward-kill)))

    ;; A few more useful configurations...
    (use-package emacs
      :init
      ;; Add prompt indicator to `completing-read-multiple'.
      ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
      (defun crm-indicator (args)
        (cons (format "[CRM%s] %s"
                      (replace-regexp-in-string
                       "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                       crm-separator)
                      (car args))
              (cdr args)))
      (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

      ;; Do not allow the cursor in the minibuffer prompt
      (setq minibuffer-prompt-properties
            '(read-only t cursor-intangible t face minibuffer-prompt))
      (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

      ;; Enable recursive minibuffers
      (setq enable-recursive-minibuffers t))
#+end_src

** Consult

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  ;; Example configuration for Consult
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (
           ;; TODO generalize (hehe, see what I did there) these keybinds later
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<"))

  ;; Buffer management
  (ns/leader-spc
    ;; repeat-complex-command
    "M-:" 'consult-complex-command
    "b"   '(:ignore t :wk "consult buffer selection")
    ;; switch-to-buffer
    "bb"  '(consult-buffer :wk "consult buffer")
    ;; switch-to-buffer-other-window
    "b/"  '(consult-buffer-other-window :wk "open buffer in another window")
    ;; switch-to-buffer-other-frame
    "b\\" '(consult-buffer-other-frame :wk "open buffer in another frame")
    ;; bookmark-jump
    "br"  '(consult-bookmark :wk "bookmark jump")
    ;; project-switch-to-buffer
    "bp"  '(consult-project-buffer :wk "switch between project buffers"))

  ;; C-c bindings in `mode-specific-map'
  (general-def 'normal
    :keymaps 'mode-specific-map
    :prefix "C-c"
    "M-x" 'consult-mode-command
    "h"   'consult-history
    "k"   'consult-kmacro
    "m"   'consult-man
    "i"   'consult-info)

  ;; M-g bindings in `goto-map'
  (general-def 'normal
    :keymaps 'goto-map
    :prefix "M-g"
    "f"   'consult-flymake         ;; Alternative: consult-flycheck
    "g"   'consult-goto-line       ;; orig. goto-line
    "M-g" 'consult-goto-line       ;; orig. goto-line
    "o"   'consult-outline         ;; Alternative: consult-org-heading
    "m"   'consult-mark
    "k"   'consult-global-mark
    "i"   'consult-imenu
    "I"   'consult-imenu-multi)

  ;; M-s bindings in `search-map'
  (general-def '(normal insert visual emacs)
    :keymaps 'search-map
    :prefix "M-s"
    "d"   'consult-find            ;; Alt: consult-fd
    "D"   'consult-locate
    "g"   'consult-grep
    "G"   'consult-git-grep
    "r"   'consult-ripgrep
    "k"   'consult-keep-lines
    "u"   'consult-focus-lines)

  ;; C-s bindings in `search-mode-map'
  ;; Prefer `consult-line' over Isearch for a swiper-like experience
   (general-def 'override
     :keymaps 'isearch-mode-map
     "C-s" 'consult-line)

  ;; Other custom bindings
  (general-def 'override "M-y" 'consult-yank-pop) ;; orig. yank-pop

#+end_src

#+RESULTS:

** Orderless

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package orderless
    :custom
    (completion-styles '(orderless))
    (completion-category-overrides '((file (styles . (partial-completion))))))
#+end_src

#+RESULTS:

** Embark

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package embark
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
    ;; strategy, if you want to see the documentation from multiple providers.
    (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
    ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

  (general-def 'override
    "C-."   'embark-act
    "C-;"   'embark-dwim
    "C-h B" 'embark-bindings)
#+end_src

#+RESULTS:

** Marginalia
The [[https://github.com/minad/marginalia][Marginalia]] package adds marginalia annotations to the minibuffer completions.

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  ;; Enable rich annotations using the Marginalia package
  (use-package marginalia
    :after vertico
    :demand t
    :config
    (marginalia-mode))
#+end_src

#+RESULTS:
: marginalia-cycle

** Corfu
[[https://github.com/minad/corfu][Corfu]] enhances in-buffer completion with a small completion popup.

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package corfu
    ;; :general
    ;; (general-def 'corfu-mode-map
    ;;   "C-j" 'corfu-next
    ;;   "C-k" 'corfu-previous
    ;;   "TAB" 'corfu-insert
    ;;   "C-f" 'corfu-insert)
    :custom
    (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    (corfu-separator ?\s)          ;; Orderless field separator
    :init
    (global-corfu-mode))

  (use-package emacs
    :init
    (setq tab-always-indent 'complete))
#+end_src


#+RESULTS:

** Helpful
[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers.  For example, if you use =describe-function=, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration.

#+begin_src emacs-lisp :tangle "lisp/ui-config.el" :mkdirp yes
  (use-package helpful
    :commands (helpful-callable helpful-variable helpful-command helpful-key)
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))
#+end_src
** Avy
Avy is useful for jumping around the screen and selecting different elements.

#+begin_src emacs-lisp :tangle no :mkdirp yes
  ;;(use-package avy
  ;;  :general
  ;;  (ns/leader-spc
  ;;    "j"   '(:ignore t :which-key "jump")
  ;;    "jj"  '(avy-goto-char :which-key "jump to char")
  ;;    "jw"  '(avy-goto-word-0 :which-key "jump to word")
  ;;    "jl"  '(avy-goto-line :which-key "jump to line")))
#+end_src

* Org
My capture templates, agenda views, and other Org customizations can be found in [[ns-orgmode.org]].

** Font Faces

The =efs/org-font-setup= function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we're editing a document in =org-mode=.  We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (defun efs/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    ;; (set-face-attribute 'org-block nil    :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-block nil    :foreground 'unspecified :inherit 'fixed-pitch)
    (set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
    (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)
    (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
    (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch))
#+end_src

#+RESULTS:
: efs/org-font-setup

** Basic Org Config
This section contains the basic configuration for =org-mode= plus the configuration for Org agendas and capture templates.

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (defun ns/org-mode-setup ()
    (org-indent-mode)
    (flyspell-mode)
    ;; (variable-pitch-mode)
    (visual-line-mode 1))

  (use-package org
    :ensure nil ; Built-in to emacs, do not install.
    :commands (org-capture org-agenda)
    :hook
    (org-mode . ns/org-mode-setup)
    :custom
    (org-M-RET-may-split-line '((default . nil)))
    (org-insert-heading-respect-content t)
    (org-log-done 'time)
    (org-log-into-drawer t)
    :config
    (setq org-ellipsis " ▾"
          org-hide-emphasis-markers t
          org-src-fontify-natively t
          org-fontify-quote-and-verse-blocks t
          org-hide-block-startup nil
          org-startup-folded 'content
          org-cycle-separator-lines 2
          org-capture-bookmark nil)

    (setq org-modules
          '(org-habit))

    ;; Resize latex figures
    (setq org-format-latex-options
          (plist-put org-format-latex-options :scale 1.5))

    (setq org-habit-graph-column 60)

    ;; Save Org buffers after refiling!
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (efs/org-font-setup))
     #+end_src

     #+RESULTS:
     | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | org-tempo-setup | (lambda nil evil-org-mode) | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | org-appear-mode | efs/org-mode-visual-fill | org-bullets-mode | ns/org-mode-setup | rainbow-delimiters-mode | (lambda nil (display-line-numbers-mode 0)) |

** Org Agenda

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  ;; Open the agenda file as the only window
  (setq org-agenda-window-setup 'only-window)
  (setq org-agenda-files
        '("~/ark/org/agenda/todo.org"       ; General unsorted todo items.
          "~/ark/org/agenda/inbox.org"      ; TBD!
          "~/ark/org/agenda/contacts.org"   ; Contacts list.
          "~/ark/org/agenda/projects.org"))

  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
          (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "PROJECT(x)" "|" "COMPLETED(c)" "CANC(k@)")
          (sequence "CONTACT(C)")))

  (setq org-refile-targets
        '(("archive.org" :maxlevel . 1)
          ("todo.org" :maxlevel . 1)))

  (setq org-tag-alist
        '((:startgroup)
                                          ; Put mutually exclusive tags here
          (:endgroup)
          ("@errand" . ?E)
          ("@home" . ?H)
          ("@work" . ?W)
          ("@investing" . ?I)
          ("agenda" . ?a)
          ("followup" . ?f)
          ("planning" . ?p)
          ("publish" . ?P)
          ("batch" . ?b)
          ("note" . ?n)
          ("idea" . ?i)))

  ;; Configure custom agenda views
  ;; More on agenda view commands at `https://emacsdocs.org/docs/org/Agenda-Commands'
  (setq org-agenda-custom-commands
        `(("A" "Daily agenda and top priority tasks"
           ((tags-todo "*"
                       ((org-agenda-skip-function '(org-agenda-skip-if nil '(timestamp)))
                        (org-agenda-skip-function
                         `(org-agenda-skip-entry-if
                           'notregexp ,(format "\\[#%s\\]" (char-to-string org-priority-highest))))
                        (org-agenda-block-separator nil)
                        (org-agenda-overriding-header "Important Tasks Without a Date\n")))
            (agenda "" ((org-agenda-span 1)
                        (org-deadline-warning-days 0)
                        (org-agenda-block-separator nil)
                        (org-scheduled-past-days 0)
                        (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                        (org-agenda-format-date "%A %-e %B %Y")
                        (org-agenda-overriding-header "\nToday's Agenda\n")))
            (agenda "" ((org-agenda-start-on-weekday nil)
                        (org-agenda-start-day "+1d")
                        (org-agenda-span 3)
                        (org-deadline-warning-days 0)
                        (org-agenda-block-separator nil)
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                        (org-agenda-overriding-header "\nNext Three Days\n")))
            (agenda "" ((org-agenda-time-grid nil)
                        (org-agenda-start-on-weekday nil)
                        ;; We don't want to replicate the previous section's
                        ;; three days, so we start counting from the day after.
                        (org-agenda-start-day "+4d")
                        (org-agenda-span 14)
                        (org-agenda-show-all-dates nil)
                        (org-deadline-warning-days 0)
                        (org-agenda-block-separator nil)
                        (org-agenda-entry-types '(:deadline))
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                        (org-agenda-overriding-header "\nUpcoming Deadlines (+14d)\n")))
            (todo "PROJECT"
                  ((org-agenda-skip-function '(org-agenda-skip-if nil '(timestamp)))
                   (org-agenda-block-separator nil)
                   (org-agenda-overriding-header "\nProjects\n")))
            ))

          ("d" "Dashboard"
           ((agenda ""
                    (
                     (org-agenda-span 7)
                     (org-deadline-warning-days 0)
                     (org-scheduled-past-days 0)
                     (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                     (org-agenda-format-date "%A %-e %B %Y")
                     (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))
            (tags-todo "+PRIORITY=\"A\""
                       ((org-agenda-overriding-header "High Priority")))
            (tags-todo "+followup" ((org-agenda-overriding-header "Needs Follow Up")))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Actions")
                   (org-agenda-max-todos nil)))
            (todo "TODO"
                  ((org-agenda-overriding-header "Unprocessed Inbox Tasks")
                   (org-agenda-files '("~/ark/org/agenda/inbox.org"))
                   (org-agenda-text-search-extra-files nil)))
            (agenda "" ((org-agenda-span 14)
                        (org-agenda-start-day "+7d")
                        (org-deadline-warning-days 0)
                        (org-agenda-block-separator nil)
                        (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                        (org-agenda-format-date "%A %-e %B %Y")
                        (org-agenda-entry-types '(:deadline :scheduled))
                        (org-agenda-overriding-header "Upcoming Deadlines (+14d)")))
            ))
          ))

  (setq org-capture-templates
        `(("t" "Tasks")
          ("tt" "Task" entry (file "~/ark/org/agenda/todo.org")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("ts" "Clocked Entry Subtask" entry (clock)
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("tr" "Recurring Task" entry (file "~/ark/org/agenda/recurrent.org")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

          ;; Projects
          ("p" "Projects")
          ("pt" "Task" entry (file "~/ark/org/agenda/projects.org")
           "* PROJECT %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("ps" "Clocked Entry Subtask" entry (clock)
           "* PROJECT %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("pr" "Pull Request" entry (file "~/ark/org/agenda/projects.org")
           "* TODO %?\n  :PROPERTIES:\n:DATE: %U\n:LINK: %^L \n:END:" :empty-lines 1)

          ;; Contacts
          ("c" "Contacts" entry (file "~/ark/org/agenda/contacts.org")
           "* CONTACT %^{Name}\n:PROPERTIES:\n:DATE: %^{Specify birthday}t\n:PHONE: %^{Phone number}\n:END:\n%?" :empty-lines 1)

          ;; Journal Entries
          ("j" "Journal Entries")
          ("je" "General Entry" entry
           (file+olp+datetree "~/ark/org/journal/journal.org")
           "\n* %<%I:%M %p> - %^{Title} \n\n%?\n\n"
           :tree-type week
           :clock-in :clock-resume
           :empty-lines 1)
          ("jt" "Task Entry" entry
           (file+olp+datetree "~/ark/org/journal/journal.org")
           "\n* %<%I:%M %p> - Task Notes: %a\n\n%?\n\n"
           :tree-type week
           :clock-in :clock-resume
           :empty-lines 1)
          ("jj" "Journal" entry
           (file+olp+datetree "~/ark/org/journal/journal.org")
           "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
           :tree-type week
           :clock-in :clock-resume
           :empty-lines 1)))

  (define-key global-map (kbd "C-c j")
              (lambda () (interactive) (org-capture nil "jj")))

#+end_src

#+RESULTS:
| lambda | nil | (interactive) | (org-capture nil jj) |

** Nicer Heading Bullets
org-bullets replaces the heading stars in org-mode buffers with nicer looking characters that you can control.

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
 #+end_src

** Center Org Buffers
We use visual-fill-column to center org-mode buffers for a more pleasing writing experience as it centers the contents of the buffer horizontally to seem more like you are editing a document.

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (defun efs/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . efs/org-mode-visual-fill))
 #+end_src

** Auto-show Markup Symbols
#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (use-package org-appear
     :hook (org-mode . org-appear-mode))
#+end_src

* Org Modules and Packages
** Evil Org
#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (use-package evil-org
    :after org
    :hook (org-mode . (lambda () evil-org-mode))
    :config
    (require 'evil-org-agenda)
    (evil-org-set-key-theme '(navigation todo insert textobjects additional))
    (evil-org-agenda-set-keys))

  (ns/leader-spc 'override
    "o"   '(:ignore t :wk "org mode")

    "oi"  '(:ignore t :wk "insert")
    "oil" '(org-insert-link :wk "insert link")

    "oo"  '(org-agenda :wk "open agenda")

    "on"  '(org-toggle-narrow-to-subtree :wk "toggle narrow")
    "os"  '(consult-org-roam-search :wk "search notes")
    ;; "oa"  '(org-agenda :wk "status")
    "ot"  '(org-todo-list :wk "todos")
    "oc"  '(org-capture t :wk "capture")
    "ox"  '(org-export-dispatch t :wk "export"))

  (defun ns/open-custom-agenda ()
    "Open the custom agenda view."
    (interactive)
    (org-agenda nil "d"))

  (general-def 'override
    :prefix "C-c"
    "a" '(org-agenda :wk "org agenda")
    "c" '(org-capture :wk "org capture")
    "d" '(ns/open-custom-agenda :wk "main agenda dashboard")
    )
#+end_src

#+RESULTS:

** Babel
To execute or export code in =org-mode= code blocks, you'll need to set up =org-babel-load-languages= for each language you'd like to use.  [[https://orgmode.org/worg/org-contrib/babel/languages.html][This page]] documents all of the languages that you can use with =org-babel=.

#+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
  (with-eval-after-load 'org
    (org-babel-do-load-languages
        'org-babel-load-languages
        '(
          (emacs-lisp . t)
          (python . t)
          (shell . t)
          (C . t)
         ))
    (push '("conf-unix" . conf-unix) org-src-lang-modes))
  ;; Disable execution confirmations
  (setq org-confirm-babel-evaluate nil)
#+end_src

#+RESULTS:

** Structure Templates
Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files in combination with =org-tempo= by typing followed by the template name like =el= or =py= and then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =el= and press =TAB= to expand into such a block.

You can add more =src= block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].

 #+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
   (use-package org-tempo
     :ensure nil
     :after org
     :config
     (let ((templates '(("sh"  . "src sh")
                        ("el"  . "src emacs-lisp")
                        ("ini" . "src emacs-lisp :tangle \"init.el\" :mkdirp yes")
                        ("vim" . "src vim")
                        ("py"  . "src python")
                        ("cs"  . "src csharp")
                        ;; Leetcode snippet
                        ("leet" .
                         "src C++ :includes <iostream> :flags -I./src/util -std=c++20 :tangle src/ .cpp")

                        ("cpp" . "src C++ :includes <iostream>"))))
       (dolist (template templates)
         (push template org-structure-template-alist))))
#+end_src

#+RESULTS:
: t

** Org Journal
 #+begin_src emacs-lisp :tangle "lisp/org-config.el" :mkdirp yes
   (use-package org-journal
     :custom
     (org-journal-dir "~/ark/org/journal/")
     )
 #+end_src

 #+RESULTS:

* Org Roam
** Org Roam Config
[[[[https://github.com/org-roam/org-roam]]][Org Roam]] is a plain-text, graph-based personal knowledge management system.

#+begin_src emacs-lisp :tangle "lisp/org-roam-config.el" :mkdirp yes
  (use-package org-roam
    :custom
    (org-roam-directory (file-truename "~/ark/org"))
    (org-roam-dailies-directory "~/ark/org/journal")
    (org-roam-completion-everywhere t)
    (org-roam-db-autosync-mode)
    ;; :config
    ;; (org-roam-db-autosync-mode)

    ;; If you're using a vertical completion framework, you might want a more informative completion interface
    ;; (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
    ;; If using org-roam-protocol
    ;; (require 'org-roam-protocol)
    )

  ;; Keybindings
  (ns/leader-spc
    "n"  '(:ignore t :wk "org node selection")
    "nl" '(org-roam-buffer-toggle :wk "org roam buffer toggle")
    "nf" '(org-roam-node-find :wk "org roam buffer find")
    ;; "ng" '(org-roam-graph :wk "org roam graph")
    "ni" '(org-roam-node-insert :wk "org roam insert")
    "nc" '(org-roam-capture :wk "org roam capture")
    "nj" '(org-roam-dailies-capture-today :wk "org roam dailies capture today"))

#+end_src

#+RESULTS:

** Org Roam Capture Templates
Org roam allows you to create various capture templates.

#+begin_src emacs-lisp :tangle "lisp/org-roam-config.el" :mkdirp yes
  (setq org-roam-capture-templates
    '(("m" "main" plain
        "%?"
        :if-new
        (file+head "main/%<%Y%m%d%H%M%S>-${slug}.org"
                   "#+title: ${title}\n#+options: tex:t toc:nil\n#+startup: inlineimages latexpreview\n")
        :immediate-finish t
        :unnarrowed t)
        ("r" "reference" plain "%?"
        :if-new
        (file+head "reference/${title}.org"
                   "#+title: ${title}\n#+options: tex:t toc:nil\n#+startup: inlineimages latexpreview\n")
        :immediate-finish t
        :unnarrowed t)
        ("a" "article" plain "%?"
        :if-new
        (file+head "articles/${title}.org"
                   "#+title: ${title}\n#+options: tex:t toc:nil\n#+startup: inlineimages latexpreview\n#+filetags: :article:\n")
        :immediate-finish t
        :unnarrowed t)))
#+end_src

#+RESULTS:
| m | main | plain | %? | :if-new | (file+head main/%<%Y%m%d%H%M%S>-${slug}.org #+title: ${title} |

*** Define the Type of a Node

It can be useful to differentiate the different types of zettels at completion time.

#+begin_src emacs-lisp :tangle "lisp/org-roam-config.el" :mkdirp yes
  (with-eval-after-load 'org-roam
    (cl-defmethod org-roam-node-type ((node org-roam-node))
      "Return the TYPE of NODE."
      (condition-case nil
          (file-name-nondirectory
           (directory-file-name
            (file-name-directory
             (file-relative-name
              (org-roam-node-file node)
              org-roam-directory))))
        (error "")))
    )
#+end_src

#+RESULTS:
: org-roam-node-type

*** Modifying Display Template to Show Node Type

#+begin_src emacs-lisp :tangle "lisp/org-roam-config.el" :mkdirp yes
  (setq org-roam-node-display-template
        (concat "${type:15} ${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
#+end_src

** Org Roam UI Frontend
[[https://github.com/org-roam/org-roam-ui][org-roam-ui]] is a graphical frontend for displaying org roam nodes in a graph-like interface.

#+begin_src emacs-lisp :tangle "lisp/org-roam-config.el" :mkdirp yes
  (use-package websocket
    :after org-roam)

  (use-package org-roam-ui
    :after org-roam
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-default-view '2d
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))

  (ns/leader-spc
    "ng" '(org-roam-ui-mode :wk "org roam ui graph"))
#+end_src

#+RESULTS:

* Development

** LSP

*** lsp-mode
[[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]] enables IDE-like functionality for many different programming languages via "language servers" that speak the [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]].  Before trying to set up =lsp-mode= for a particular language, check out the [[https://emacs-lsp.github.io/lsp-mode/page/languages/][documentation for your language]] so that you can learn which language servers are available and how to install them.

The =lsp-keymap-prefix= setting enables you to define a prefix for where =lsp-mode='s default keybindings will be added.  I *highly recommend* using the prefix to find out what you can do with =lsp-mode= in a buffer.

The =which-key= integration adds helpful descriptions of the various keys so you should be able to learn a lot just by pressing =C-c l= in a =lsp-mode= buffer and trying different things that you find there.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (defun ns/lsp-mode-setup ()
    (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
    (lsp-headerline-breadcrumb-mode))

  (defun ns/prog-mode-setup ()
    (display-fill-column-indicator-mode))

  (use-package lsp-mode
    :init
    (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l'
    :hook
    ((lsp-mode . ns/lsp-mode-setup)
     (prog-mode . ns/prog-mode-setup)
     (c-mode . lsp)
     (c++-mode . lsp)
     (csharp-mode . lsp)
     (go-mode . lsp)
     (python-mode . lsp)
     (rust-mode . lsp))
    :commands lsp
    ;; :custom
    ;; (lsp-auto-configure t)
    ;; (lsp-enable-symbol-highlighting t)
    :config
    (lsp-enable-which-key-integration t)
    (setq lsp-completion-enable t)
    (setq lsp-completion-provider :capf)
    ;; (setq lsp-log-io t)
    ;; The path to lsp-mode needs to be added to load-path as well as the
    ;; path to the `clients' subdirectory.

    ;; Activate lsp-mode
    )

  (ns/leader-m 'lsp-mode-map
   "a" 'lsp-execute-code-action
   "v" 'lsp-avy-lens
   "n" 'lsp-describe-thing-at-point
   ;; "i" 'lsp-goto-implementation
   "d" 'lsp-find-definition
   "D" 'lsp-find-declaration
   "t" 'lsp-find-type-definition
   "x" 'lsp-find-references
   "r" 'lsp-rename
   "R" 'lsp-restart-workspace
   "=" 'lsp-format-buffer
   "l" 'lsp-workspace-show-log)
#+end_src

#+RESULTS:

*** lsp-ui
[[https://emacs-lsp.github.io/lsp-ui/][lsp-ui]] is a set of UI enhancements built on top of =lsp-mode= which make Emacs feel even more like an IDE.  Check out the screenshots on the =lsp-ui= homepage (linked at the beginning of this paragraph) to see examples of what it can do.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package lsp-ui
    :after lsp-mode
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-position 'at-point)
    (lsp-ui-doc-delay 0.0)
    (lsp-ui-sideline-show-code-actions nil)
    )

  (ns/leader-m 'lsp-mode-map
   "i" 'lsp-ui-doc-glance)
#+end_src

#+RESULTS:

*** consult-lsp
LSP integration with consult.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package consult-lsp
    :after lsp-mode
    :general
    (ns/leader-m 'lsp-mode-map
      "y" 'consult-lsp-symbols
      "e" 'consult-lsp-diagnostics))
#+end_src

#+RESULTS:

*** lsp-treemacs
[[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]] provides nice tree views for different aspects of your code like symbols in a file, references of a symbol, or diagnostic messages (errors and warnings) that are found in your code.

Try these commands with =M-x=:

- =lsp-treemacs-symbols= - Show a tree view of the symbols in the current file
- =lsp-treemacs-references= - Show a tree view for the references of the symbol under the cursor
- =lsp-treemacs-error-list= - Show a tree view for the diagnostic messages in the project

This package is built on the [[https://github.com/Alexander-Miller/treemacs][treemacs]] package which might be of some interest to you if you like to have a file browser at the left side of your screen in your editor.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package lsp-treemacs
    :after lsp)
#+end_src

#+RESULTS:

** Tree Sitter
Tree sitter support is now built in to Emacs. This seems to be breaking lsp-mode, so I've disabled this for now.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package treesit-auto
    :disabled t
    :demand t
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))
#+end_src

#+RESULTS:

** Debugging with dap-mode
[[https://emacs-lsp.github.io/dap-mode/][dap-mode]] is an excellent package for bringing rich debugging capabilities to Emacs via the [[https://microsoft.github.io/debug-adapter-protocol/][Debug Adapter Protocol]].  You should check out the [[https://emacs-lsp.github.io/dap-mode/page/configuration/][configuration docs]] to learn how to configure the debugger for your language.  Also make sure to check out the documentation for the debug adapter to see what configuration parameters are available to use for your debug templates!

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package dap-mode
    :after lsp-mode
    :config
    (dap-mode 1)
    (dap-ui-mode 1)
    (dap-tooltip-mode 1))
#+end_src

** Company Mode
[[http://company-mode.github.io/][Company Mode]] provides a nicer in-buffer completion interface than =completion-at-point= which is more reminiscent of what you would expect from an IDE.  We add a simple configuration to make the keybindings a little more useful (=TAB= now completes the selection and initiates completion at the current location if needed).

We also use [[https://github.com/sebastiencs/company-box][company-box]] to further enhance the look of the completions with icons and better overall presentation.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package company
    :after lsp-mode
    :hook (lsp-mode . company-mode)
    :bind (:map company-active-map
           ("<tab>" . company-complete-selection))
          (:map lsp-mode-map
           ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))

  (use-package company-box
    :hook (company-mode . company-box-mode))
#+end_src

** TRAMP Mode
TRAMP (Transparent remote access, multiple protocols) allows users to edit remote files.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  ;; Setup TRAMP mode
  (setq tramp-default-method "ssh")
#+end_src

#+RESULTS:
: ssh

** Yasnippet
A template system for Emacs.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package yasnippet
    :disabled t
    :general
    (ns/leader-ct 'override
      "Y" #'yas-new-snippet)
    :config
    ;; Don't expand snippets in normal mode
    (general-def 'normal yas-minor-mode-map
      [remap yas-expand] #'ignore)
    (general-def input-decode-map "C-i" [C-i])
    (general-def 'insert yas-minor-mode-map
      "<C-i>" #'yas-expand))
#+end_src

#+RESULTS:

*** Extra Snippets
#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package yasnippet-snippets
    :disabled t
    :after yasnippet
    :demand t
    :config
    ;; Necessary for my personal snippets to override some of these
  (yas-reload-all))
#+end_src

*** Consult Yasnippet
A better ~yas-insert-snippet~.
#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package consult-yasnippet
    :disabled t
    :general ('insert "C-<tab>" #'consult-yasnippet))
#+end_src

#+RESULTS:

** Projectile
[[https://projectile.mx/][Projectile]] is a project management library for Emacs which makes it a lot easier to navigate around code projects for various languages.  Many packages integrate with Projectile so it's a good idea to have it installed even if you don't use its commands directly.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    ;; :custom ((projectile-completion-system 'ivy))
    :custom ((projectile-completion-system 'default))
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    ;; NOTE: Set this to the folder where you keep your Git repos!
    (when (file-directory-p "~/git")
      (setq projectile-project-search-path '("~/git")))
    (setq projectile-switch-project-action #'projectile-dired))

  (ns/leader-m 'override
    "p"  '(:ignore p :wk "projectile commands")
    "pf" '(projectile-find-file :wk "projectile find file")
    "ps" '(projectile-switch-project :wk "projectile switch project")
    "pg" '(consult-ripgrep :wk "consult ripgrep")
    "pp" '(projectile-find-file :wk "projectile find file")
    "pc" '(projectile-compile-project :wk "projectile compile project")
    "pd" '(projectile-dired :wk "projectile dired"))

  ;; (use-package counsel-projectile
  ;;   :after projectile
  ;;   :config (counsel-projectile-mode))
#+end_src

#+RESULTS:

** Magit
[[https://magit.vc/][Magit]] is the best Git interface I've ever used.  Common Git operations are easy to execute quickly using Magit's command panel system.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package magit
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  (use-package forge
    :after magit)

  (ns/leader-m 'override
    "g"  '(:ignore g :wk "magit commands")
    "gs" '(magit-status :wk "git status")
    "gd" '(magit-diff :wk "git diff")
    "gl " '(magit-log :wk "git log")
    ;; Pushing and pulling
    "gk " '(magit-push :wk "git push")
    "gj " '(magit-pull  :wk "git pull")
    "gc " '(magit-commit :wk "git commit")
    "ga " '(magit-stage :wk "git add")
    "gi " '(magit-init :wk "git init"))
#+end_src

#+RESULTS:

** Forge
Forge allows use to work with varios git forges using the magit interface.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
  (use-package forge
    :after 'magit)
#+end_src

#+RESULTS:

** Flymake
#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
    ;; (defun ns/flymake-cc-default ()
    ;;   "Default compile command for C++ files without a Makefile."
    ;;   (if buffer-file-name
    ;;       (let (
    ;;             (base-name  (file-name-sans-extension (file-name-nondirectory buffer-file-name))))
    ;;         (concat "g++ --std=c++23 -g -o "
    ;;                 base-name
    ;;                 " " base-name ".cpp"
    ;;                 " && ./" base-name))
    ;;         (message "Buffer is not visiting a file")))

    ;; (use-package flymake
    ;;   :hook (c++-mode . flymake-mode)
    ;;   :custom
    ;;   ;; Automatically continue without needing to hit Enter
    ;;   (compilation-read-command nil)
    ;;   :config
    ;;   (setq-default compile-command '(ns/flymake-cc-default))
    ;;   )

    ;; (general-def '(normal insert visual)
    ;;   :keymaps 'c++-mode-map
    ;;   "C-c C-c" 'compile)
#+end_src

#+RESULTS:

** Rainbow Delimiters
[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] is useful in programming modes because it colorizes nested parentheses and brackets according to their nesting depth.  This makes it a lot easier to visually match parentheses in Emacs Lisp code without having to count them yourself.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package rainbow-delimiters
    :hook
    (prog-mode . rainbow-delimiters-mode)
    (org-mode . rainbow-delimiters-mode)
    (lisp-mode . rainbow-delimiters-mode))
#+end_src

** Smartparens
[[https://github.com/Fuco1/smartparens][Smartparens]] is a minor mode for dealing with pairs in Emacs.

#+begin_src emacs-lisp :tangle "lisp/development-config.el" :mkdirp yes
  (use-package smartparens
    ;; :hook (prog-mode text-mode markdown-mode) ;; add `smartparens-mode` to these hooks
    :init
    (smartparens-global-mode)
    :config
    ;; load default config
    (require 'smartparens-config))
#+end_src

#+RESULTS:
: t

* Programming Languages
** C/C++

#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes
  (use-package ccls
    :custom
    (ccls-executable "ccls"))
#+end_src

#+RESULTS:

** Common Lisp

#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes
  ;; Load SLY
  ;; (require 'sly)
  ;; Set the Common Lisp implementation to SBCL
  ;; (setq inferior-lisp-program "/usr/bin/sbcl")

  ;; (add-to-list 'sly-contribs 'sly-asdf 'append)

#+end_src

#+RESULTS:

** Go
#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes
  (use-package go-mode
    :hook
    (go-mode . lsp-deferred))
#+end_src

#+RESULTS:
| lsp-deferred | doom-modeline-env-setup-go |

** Guile
Setup for guile scheme development.
#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp
  (use-package geiser
    :config
    (setq geiser-active-implementations '(guile)))

  (use-package geiser-guile)
#+end_src

** Python
We use =lsp-mode= and =dap-mode= to provide a more complete development environment for Python in Emacs.  Check out [[https://emacs-lsp.github.io/lsp-mode/page/lsp-pyls/][the =pyls= configuration]] in the =lsp-mode= documentation for more details.

Make sure you have the =pyls= language server installed before trying =lsp-mode=!

#+begin_src sh :tangle no

pip install --user "python-language-server[all]"

#+end_src

There are a number of other language servers for Python so if you find that =pyls= doesn't work for you, consult the =lsp-mode= [[https://emacs-lsp.github.io/lsp-mode/page/languages/][language configuration documentation]] to try the others!

#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes
  (use-package python-mode
    :hook (python-mode . lsp-deferred)
    :custom
    (lsp-pyls-server-command '("/home/nick/.local/lib/python3.10/site-packages/pyls
  "))
    ;; NOTE: Set these if Python 3 is called "python3" on your system!
    ;; (python-shell-interpreter "python3")
    ;; (dap-python-executable "python3")
    (dap-python-debugger 'debugpy)
    :config
    (setq-default python-indent-offset 4))
#+end_src

#+RESULTS:

You can use the pyvenv package to use =virtualenv= environments in Emacs.  The =pyvenv-activate= command should configure Emacs to cause =lsp-mode= and =dap-mode= to use the virtual environment when they are loaded, just select the path to your virtual environment before loading your project.

#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes

  ;; (use-package pyvenv
  ;;   :after python-mode
  ;;   :config
  ;;   (pyvenv-mode 1))

#+end_src

#+RESULTS:
: t

** Rust
#+begin_src emacs-lisp :tangle "lisp/programming-languages-config.el" :mkdirp yes
  (use-package rust-mode
    :hook
    (rust-mode . lsp-deferred))
#+end_src

#+RESULTS:
| lsp-deferred | lsp | doom-modeline-env-setup-rust |

* Terminals
** term-mode

=term-mode= is a built-in terminal emulator in Emacs.  Because it is written in Emacs Lisp, you can start using it immediately with very little configuration.  If you are on Linux or macOS, =term-mode= is a great choice to get started because it supports fairly complex terminal applications (=htop=, =vim=, etc) and works pretty reliably.  However, because it is written in Emacs Lisp, it can be slower than other options like =vterm=.  The speed will only be an issue if you regularly run console apps with a lot of output.

One important thing to understand is =line-mode= versus =char-mode=.  =line-mode= enables you to use normal Emacs keybindings while moving around in the terminal buffer while =char-mode= sends most of your keypresses to the underlying terminal.  While using =term-mode=, you will want to be in =char-mode= for any terminal applications that have their own keybindings.  If you're just in your usual shell, =line-mode= is sufficient and feels more integrated with Emacs.

With =evil-collection= installed, you will automatically switch to =char-mode= when you enter Evil's insert mode (press =i=).  You will automatically be switched back to =line-mode= when you enter Evil's normal mode (press =ESC=).

Run a terminal with =M-x term!=

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =C-c C-k= - Enter char-mode
- =C-c C-j= - Return to line-mode
- If you have =evil-collection= installed, =term-mode= will enter char mode when you use Evil's Insert mode

#+begin_src emacs-lisp :tangle "lisp/terminal-config.el" :mkdirp yes
  (use-package term
    :commands term
    :config
    (setq explicit-shell-file-name "bash") ;; Change this to zsh, etc
    ;;(setq explicit-zsh-args '())         ;; Use 'explicit-<shell>-args for shell-specific args

    ;; Match the default Bash shell prompt.  Update this if you have a custom prompt
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))
#+end_src

*** Better term-mode colors

The =eterm-256color= package enhances the output of =term-mode= to enable handling of a wider range of color codes so that many popular terminal applications look as you would expect them to.  Keep in mind that this package requires =ncurses= to be installed on your machine so that it has access to the =tic= program.  Most Linux distributions come with this program installed already so you may not have to do anything extra to use it.

#+begin_src emacs-lisp :tangle "lisp/terminal-config.el" :mkdirp yes
  (use-package eterm-256color
    :hook (term-mode . eterm-256color-mode))
#+end_src

** vterm

[[https://github.com/akermu/emacs-libvterm/][vterm]] is an improved terminal emulator package which uses a compiled native module to interact with the underlying terminal applications.  This enables it to be much faster than =term-mode= and to also provide a more complete terminal emulation experience.

Make sure that you have the [[https://github.com/akermu/emacs-libvterm/#requirements][necessary dependencies]] installed before trying to use =vterm= because there is a module that will need to be compiled before you can use it successfully.

#+begin_src emacs-lisp :tangle "lisp/terminal-config.el" :mkdirp yes
  (use-package vterm
    :commands vterm
    :config
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
    ;;(setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
    (setq vterm-max-scrollback 10000))
#+end_src

** shell-mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interactive-Shell.html#Interactive-Shell][shell-mode]] is a middle ground between =term-mode= and Eshell.  It is *not* a terminal emulator so more complex terminal programs will not run inside of it.  It does have much better integration with Emacs because all command input in this mode is handled by Emacs and then sent to the underlying shell once you press Enter.  This means that you can use =evil-mode='s editing motions on the command line, unlike in the terminal emulator modes above.

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-shell-history= - A searchable history of commands typed into the shell

One advantage of =shell-mode= on Windows is that it's the only way to run =cmd.exe=, PowerShell, Git Bash, etc from within Emacs.  Here's an example of how you would set up =shell-mode= to run PowerShell on Windows:

#+begin_src emacs-lisp :tangle "lisp/terminal-config.el" :mkdirp yes
  (when (eq system-type 'windows-nt)
    (setq explicit-shell-file-name "powershell.exe")
    (setq explicit-powershell.exe-args '()))
#+end_src

** Eshell

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#Contributors-to-Eshell][Eshell]] is Emacs' own shell implementation written in Emacs Lisp.  It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (=ls=, =rm=, =mv=, =grep=, etc).  It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing =vim= to =find-file=).  Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don't work as well.  However, many of these limitations can be dealt with by good configuration and installing external packages, so don't let that discourage you from trying it!

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-esh-history= - A searchable history of commands typed into Eshell

We will be covering Eshell more in future videos highlighting other things you can do with it.

For more thoughts on Eshell, check out these articles by Pierre Neidhardt:
- https://ambrevar.xyz/emacs-eshell/index.html
- https://ambrevar.xyz/emacs-eshell-versus-shell/index.html

#+begin_src emacs-lisp :tangle "lisp/terminal-config.el" :mkdirp yes
  (defun efs/configure-eshell ()
    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Bind some useful keys for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
    (evil-normalize-keymaps)

    (setq eshell-history-size         10000
          eshell-buffer-maximum-lines 10000
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t))

  (use-package eshell-git-prompt
    :after eshell)

  (use-package eshell
    :hook (eshell-first-time-mode . efs/configure-eshell)
    :config

    (with-eval-after-load 'esh-opt
      (setq eshell-destroy-buffer-when-process-dies t)
      (setq eshell-visual-commands '("htop" "zsh" "vim")))

    (eshell-git-prompt-use-theme 'powerline))
#+end_src

* Applications
** Elfeed

#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
  (use-package elfeed
    :commands elfeed
    :config
    (setq elfeed-feeds rss-feeds))
  ;; (add-hook 'elfeed-new-entry-hook
  ;;           (elfeed-make-tagger :feed-url "youtube\\.com"
  ;; :add '(video youtube)))
#+end_src
** IRC
=rcirc= is an IRC client for Emacs.
#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
  (use-package rcirc
    :custom
    (rcirc-default-nick "nshan651")
    (rcirc-default-user-name "nshan651")
    (rcirc-default-full-name "ns")
    (rcirc-server-alist `(("irc.libera.chat"
  			 :channels ("#emacs" "#guix")
                           :port 6697
                           :encryption tls)))
    (rcirc-prompt "%t> ")
    (rcirc-timeout-seconds most-positive-fixnum)

    (rcirc-reconnect-delay 5)
    (rcirc-fill-column 90)
    (rcirc-track-ignore-server-buffer-flag t))
  #+end_src

** Ox-hugo
Website publishing.

#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
(use-package ox-hugo
  :after ox)
#+end_src

#+RESULTS:
** Org-caldav
Calendar syncing using the =caldav= protocol.
#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
  (use-package org-caldav
    :custom
    ;; URL of the caldav server
    (org-caldav-url
     "http://nextcloud.nshan651.duckdns.org/nextcloud/remote.php/dav/calendars/nshan651")

    ;; calendar ID on server
    (org-caldav-calendar-id "personal")

    ;; Org filename where new entries from calendar stored
    (org-caldav-inbox "~/ark/org/agenda/todo.org")

    ;; Additional Org files to check for calendar events
    (org-caldav-files nil)

    ;; Usually a good idea to set the timezone manually
    (org-icalendar-timezone "America/Chicago")

    ;; TODO
    (org-caldav-sync-todo t)
    (org-caldav-todo-deadline-schedule-warning-days t)

    (org-icalendar-include-todo 'all)
    ;; (org-icalendar-use-deadline 'todo-due)
    ;; (org-icalendar-use-scheduled 'todo-start)
    (org-icalendar-use-deadline '(event-if-todo event-if-not-todo todo-due))
    (org-icalendar-use-scheduled '(event-if-todo event-if-not-todo todo-start))
    (org-icalendar-with-timestamps t)
  )
#+end_src

#+RESULTS:
** Guix
The Gnu Guix interface.
#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
  ;; (use-package guix)
#+end_src
** gptel
A simple llm interface for emacs.

#+begin_src emacs-lisp :tangle "lisp/applications-config.el" :mkdirp yes
  (use-package gptel
    :custom
    (gptel-default-mode 'org-mode)
    (gptel-model 'llama3.2:latest)
    :config
    (setq gptel-backend (gptel-make-ollama "shodan"
                     :host "shodan.local:11434"
                     :stream t
                     :models '(gemma3:1b
                               gemma3:latest
                               llama3.2:latest
                               phi4-mini:latest))))
#+end_src

You can use the following query to ensure that Ollama is online and serving:
#+begin_src sh
  curl http://shodan.local:11434/api/generate -d '{
    "model": "llama3.2",
    "prompt":"Why is the sky blue?"
  }'
#+end_src

* Window Management

** Perspective
#+begin_src emacs-lisp :tangle "lisp/window-config.el" :mkdirp yes
  (use-package perspective
    :custom
    (persp-initial-frame-name "main")
    (persp-mode-prefix-key (kbd "C-a"))
    :init
    (unless (equal persp-mode t)
      (persp-mode)))

  (ns/leader-ca 'persp-mode-map
    "s"  '(persp-switch :wk "query or create persp")
    "k"  '(persp-kill :wk "kill a persp")
    "r"  '(persp-rename :wk "rename a persp")
    ;; Buffer management
    "a"  '(persp-add-buffer :wk "add buffer to current persp")
    "A"  '(persp-set-buffer :wk "add buffer to current persp, remove from others")
    "b"  '(persp-switch-to-buffer :wk "switch to buffer, global by default")
    ;; Switch perspectives
    "n"  '(persp-next :wk "next persp")
    "p"  '(persp-prev :wk "previous persp")
    ;; Merging and importing
    "m"  '(persp-merge :wk "merge buffers into another persp")
    "u"  '(persp-unmerge :wk "undo effects of `persp-merge'")
    "i"  '(persp-import :wk "import a given perspective from another frame")
    ;; Save and load perspectives
    "C-s"  '(persp-state-save :wk "Save all persps in all frames to a file")
    "C-l"  '(persp-state-load :wk "load all persps from a file")
  )
 #+end_src
 #+RESULTS:

** Popper
#+begin_src emacs-lisp :tangle "lisp/window-config.el" :mkdirp yes
  (use-package popper
    :init
    (setq popper-reference-buffers
          '("\\*\\*Messages"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            help-mode
            compilation-mode))
    (popper-mode 1)
    (popper-echo-mode 1))                ; For echo area hints

  (general-def 'override
    "C-`" '(popper-toggle :wk "toggle popup")
    "M-`" '(popper-cycle :wk "cycle through popups")
    "C-M-`" '(popper-toggle-type :wk "change current buffer's toggle type"))

#+end_src

#+RESULTS:

* File Management
** Dired

Dired is a built-in file manager for Emacs that does some pretty amazing things!  Here are some key bindings you should try out:

*** Key Bindings
**** Navigation

*Emacs* / *Evil*
- =n= / =j= - next line
- =p= / =k= - previous line
- =j= / =J= - jump to file in buffer
- =RET= - select file or directory
- =^= - go to parent directory
- =S-RET= / =g O= - Open file in "" window
- =M-RET= - Show file in other window without focusing (previewing files)
- =g o= (=dired-view-file=) - Open file but in a "preview" mode, close with =q=
- =g= / =g r= Refresh the buffer with =revert-buffer= after changing configuration (and after filesystem changes!)

**** Marking files

- =m= - Marks a file
- =u= - Unmarks a file
- =U= - Unmarks all files in buffer
- =* t= / =t= - Inverts marked files in buffer
- =% m= - Mark files in buffer using regular expression
- =*= - Lots of other auto-marking functions
- =k= / =K= - "Kill" marked items (refresh buffer with =g= / =g r= to get them back)
- Many operations can be done on a single file if there are no active marks!

**** Copying and Renaming files

- =C= - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- =U= - Unmark all files in buffer
- =R= - Rename marked files, renaming multiple is a move!
- =% R= - Rename based on regular expression: =^test= , =old-\&=

*Power command*: =C-x C-q= (=dired-toggle-read-only=) - Makes all file names in the buffer editable directly to rename them!  Press =Z Z= to confirm renaming or =Z Q= to abort.

**** Deleting files

- =D= - Delete marked file
- =d= - Mark file for deletion
- =x= - Execute deletion for marks
- =delete-by-moving-to-trash= - Move to trash instead of deleting permanently

***** Creating and extracting archives

- =Z= - Compress or uncompress a file or folder to (=.tar.gz=)
- =c= - Compress selection to a specific file
- =dired-compress-files-alist= - Bind compression commands to file extension

***** Other common operations

- =T= - Touch (change timestamp)
- =M= - Change file mode
- =O= - Change file owner
- =G= - Change file group
- =S= - Create a symbolic link to this file
- =L= - Load an Emacs Lisp file into Emacs


*** Configuration

#+begin_src emacs-lisp :tangle "lisp/dired-config.el" :mkdirp yes

  (use-package dired
    :ensure nil
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump))
    :custom ((dired-listing-switches "-agho --group-directories-first"))
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "h" 'dired-single-up-directory
      "l" 'dired-single-buffer))

  (use-package dired-single
    :commands (dired dired-jump))

  ;; TODO: FIX
  ;; (use-package all-the-icons-dired
  ;;   :hook (dired-mode . all-the-icons-dired-mode))

  (use-package dired-open
    :commands (dired dired-jump)
    :config
    ;; Doesn't work as expected!
    ;;(add-to-list 'dired-open-functions #'dired-open-xdg t)
    (setq dired-open-extensions '(("png" . "feh")
                                  ("mkv" . "mpv"))))

  ;; TODO: FIX
  ;; (use-package dired-hide-dotfiles
  ;;   :hook (dired-mode . dired-hide-dotfiles-mode)
  ;;   :config
  ;;   (evil-collection-define-key 'normal 'dired-mode-map
  ;;     "H" 'dired-hide-dotfiles-mode))

#+end_src
